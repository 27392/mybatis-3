<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/es/xdoc/statement-builders.xml at 24 mayo 2022
 | Rendered using Apache Maven Fluido Skin 1.10.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <meta name="author" content="Clinton Begin" />
    <meta name="author" content="Eduardo Macarron" />
    <title>MyBatis &#x2013; MyBatis 3 | Statement Builders</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.10.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.10.0.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h2>mybatis</h2>
</div>
</div>
          <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="../../images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 24 mayo 2022<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.5.10</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html" title="Introducción"><span class="none"></span>Introducción</a></li>
    <li><a href="getting-started.html" title="Primeros pasos"><span class="none"></span>Primeros pasos</a></li>
    <li><a href="configuration.html" title="Configuración"><span class="icon-chevron-right"></span>Configuración</a></li>
    <li><a href="sqlmap-xml.html" title="Ficheros XML de mapeo"><span class="icon-chevron-right"></span>Ficheros XML de mapeo</a></li>
    <li><a href="dynamic-sql.html" title="SQL dinámico"><span class="none"></span>SQL dinámico</a></li>
    <li><a href="java-api.html" title="Java API"><span class="icon-chevron-right"></span>Java API</a></li>
    <li class="active"><a href="#"><span class="none"></span>La clase SQL</a></li>
    <li><a href="logging.html" title="Logging"><span class="none"></span>Logging</a></li>
   <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html" title="Información del proyecto"><span class="icon-chevron-right"></span>Información del proyecto</a></li>
    <li><a href="project-reports.html" title="Informes del proyecto"><span class="icon-chevron-right"></span>Informes del proyecto</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Generado por Maven" class="poweredBy"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >


  
  <section>
<h2><a name="The_SQL_Builder_Class"></a>The SQL Builder Class</h2>
  <section>
<h3><a name="El_Problema"></a>El Problema</h3>
  
<p>Una de las cosas m&#xe1;s tediosas que un programador Java puede llegar a tener que hacer es incluir c&#xf3;digo SQL en c&#xf3;digo Java. Normalmente esto se hace cuando es necesario generar din&#xe1;micamente el SQL &#x2013; de otra forma podr&#xed;as externalizar el c&#xf3;digo en un fichero o un procedimiento almacenado. Como ya has visto, MyBatis tiene una respuesta potente a la generaci&#xf3;n din&#xe1;mica de SQL mediante las capacidades del mapeo XML. Sin embargo, en ocasiones se hace necesario construir una sentencia SQL dentro del c&#xf3;digo Java. En este caso, MyBatis tiene una funcionalidad m&#xe1;s para ayudarte en ello, antes de que comiences con el t&#xed;pico l&#xed;o de signos de suma, comillas, l&#xed;neas nuevas, problemas de formato y condicionales anidados para tratar con las comas extra y las conjunciones AND&#x2026; Realmente, generar c&#xf3;digo din&#xe1;mico en java, puede ser una verdadera pesadilla. Por ejemplo:</p>

<div class="source"><pre class="prettyprint">
String sql = &quot;SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, &quot;
&quot;P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON &quot; +
&quot;FROM PERSON P, ACCOUNT A &quot; +
&quot;INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID &quot; +
&quot;INNER JOIN COMPANY C on D.COMPANY_ID = C.ID &quot; +
&quot;WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) &quot; +
&quot;OR (P.LAST_NAME like ?) &quot; +
&quot;GROUP BY P.ID &quot; +
&quot;HAVING (P.LAST_NAME like ?) &quot; +
&quot;OR (P.FIRST_NAME like ?) &quot; +
&quot;ORDER BY P.ID, P.FULL_NAME&quot;;
</pre></div>
  </section>

  <section>
<h3><a name="La_Soluci.C3.B3n"></a>La Soluci&#xf3;n</h3>
  
<p>MyBatis 3 introduce un concepto un tanto distinto para tratar con el problema.
    Con la clase SQL, puecdes crear una sentencia SQL en un s&#xf3;lo paso invocando a sus m&#xe9;todos.
    El ejemplo anterior tendr&#xed;a este aspecto si se rescribe con la clase SQL:
  </p>

      
<div class="source"><pre class="prettyprint">
private String selectPersonSql() {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
    SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
    FROM(&quot;PERSON P&quot;);
    FROM(&quot;ACCOUNT A&quot;);
    INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
    INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
    WHERE(&quot;P.ID = A.ID&quot;);
    WHERE(&quot;P.FIRST_NAME like ?&quot;);
    OR();
    WHERE(&quot;P.LAST_NAME like ?&quot;);
    GROUP_BY(&quot;P.ID&quot;);
    HAVING(&quot;P.LAST_NAME like ?&quot;);
    OR();
    HAVING(&quot;P.FIRST_NAME like ?&quot;);
    ORDER_BY(&quot;P.ID&quot;);
    ORDER_BY(&quot;P.FULL_NAME&quot;);
  }}.toString();
}
</pre></div>
    
<p>&#xbf;Qu&#xe9; hay de especial en este ejemplo?
      Bien, si lo miras detenidamente, ver&#xe1;s que no hay que preocuparse de duplicar &#x201c;AND&#x201d;s, o elegir entre &#x201c;WHERE&#x201d; o &#x201c;AND&#x201d;, o ninguno de ambos!
      La clase SQL se ocupa de colocar el &quot;WHERE&quot; donde debe de ir, si debe usarse &quot;AND&quot; o no y de realizar todas las concatenaciones de Strings.
    </p>
    </section>
      <section>
<h3><a name="La_clase_SQL"></a>La clase SQL</h3>

        
<p>Aqui van algunos ejemplos:</p>

        
<div class="source"><pre class="prettyprint">
// Anonymous inner class
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

// Builder / Fluent style
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;)
    .VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;)
    .toString();
  return sql;
}

// With conditionals (note the final parameters, required for the anonymous inner class to access them)
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;);
    FROM(&quot;PERSON P&quot;);
    if (id != null) {
      WHERE(&quot;P.ID like #{id}&quot;);
    }
    if (firstName != null) {
      WHERE(&quot;P.FIRST_NAME like #{firstName}&quot;);
    }
    if (lastName != null) {
      WHERE(&quot;P.LAST_NAME like #{lastName}&quot;);
    }
    ORDER_BY(&quot;P.LAST_NAME&quot;);
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO(&quot;PERSON&quot;);
    VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;);
    VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;);
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE(&quot;PERSON&quot;);
    SET(&quot;FIRST_NAME = #{firstName}&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}
</pre></div>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Metodo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>SELECT(String)</code>
        </li>
        
<li>
          <code>SELECT(String...)</code>
        </li>
      </ul>
    </td>
    
<td>Comienza o a&#xf1;ade a una sentencia SELECT. Se puede invocar m&#xe1;s de una vez y los par&#xe1;metros se ir&#xe1;n a&#xf1;adiendo a la sentencia SELECT. Los par&#xe1;metros son normalmente una lista de columnas o alias separados por comas, pero puede ser cualquier cosa que acepte el driver de base de datos.</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      
<ul>
        
<li>
          <code>SELECT_DISTINCT(String)</code>
        </li>
        
<li>
          <code>SELECT_DISTINCT(String...)</code>
        </li>
      </ul>
    </td>
    
<td>Comienza o a&#xf1;ade a una sentencia SELECT, tambi&#xe9;n a&#xf1;ade la palabra clave &#x201c;DISTINCT&#x201d; a la sentencia generada. Se puede invocar m&#xe1;s de una vez y los par&#xe1;metros se ir&#xe1;n a&#xf1;adiendo a la sentencia SELECT. Los par&#xe1;metros son normalmente una lista de columnas o alias separados por comas, pero puede ser cualquier cosa que acepte el driver de base de datos.</td>
  </tr>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>FROM(String)</code>
        </li>
        
<li>
          <code>FROM(String...)</code>
        </li>
      </ul>
    </td>
    
<td>Comienza o a&#xf1;ade a una cl&#xe1;usula FROM. Se puede invocar m&#xe1;s de una vez y los par&#xe1;metros se ir&#xe1;n a&#xf1;adiendo a la clausula FROM. Los par&#xe1;metros son normalmente un nombre de tabla o alias o cualquier cosa que acepte el driver de base de datos.</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      
<ul>
        
<li>
          <code>JOIN(String)</code>
        </li>
        
<li>
          <code>JOIN(String...)</code>
        </li>
        
<li>
          <code>INNER_JOIN(String)</code>
        </li>
        
<li>
          <code>INNER_JOIN(String...)</code>
        </li>
        
<li>
          <code>LEFT_OUTER_JOIN(String)</code>
        </li>
        
<li>
          <code>LEFT_OUTER_JOIN(String...)</code>
        </li>
        
<li>
          <code>RIGHT_OUTER_JOIN(String)</code>
        </li>
        
<li>
          <code>RIGHT_OUTER_JOIN(String...)</code>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva clausula JOIN del tipo apropiado, dependiendo al m&#xe9;todo que se haya llamado. El par&#xe1;metro puede incluir un join est&#xe1;ndar que consiste en las columnas y las condiciones sobre las que hacer la join.</td>
  </tr>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>WHERE(String)</code>
        </li>
        
<li>
          <code>WHERE(String...)</code>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva condici&#xf3;n a la clausula WHERE concatenada con un AND. Puede llamarse m&#xe1;s de una vez, lo cual har&#xe1; que se a&#xf1;adan m&#xe1;s condiciones todas ellas concatenadas con un AND. O usa OR() para partirlas con un OR().</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      <code>OR()</code>
    </td>
    
<td>Parte las condiciones actuales de la WHERE con un OR. Puede llamarse m&#xe1;s de una vez, pero llamarlas m&#xe1;s de una vez en la misma l&#xed;nea puede producir sentencias incorrectas.</td>
  </tr>
  
<tr class="b">
    
<td align="left">
      <code>AND()</code>
    </td>
    
<td>Parte las condiciones actuales de la WHERE con un AND. Puede llamarse m&#xe1;s de una vez, pero llamarlas m&#xe1;s de una vez en la misma l&#xed;nea puede producir sentencias incorrectas.  Dado que WHERE y HAVING concatenan autom&#xe1;ticamente el AND, es muy infrecuente que sea necesario invocar a este m&#xe9;todo y se incluye realmente por completitud.</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      
<ul>
        
<li>
          <code>GROUP_BY(String)</code>
        </li>
        
<li>
          <code>GROUP_BY(String...)</code>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva clausula GROUP BY grupo, concatenada con una coma. Se le puede llamar m&#xe1;s de una vez, lo cual har&#xe1; que se concatenen nuevas condiciones separadas tambi&#xe9;n por coma.</td>
  </tr>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>HAVING(String)</code>
        </li>
        
<li>
          <code>HAVING(String...)</code>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade una nueva clausula HAVING, concatenada con un AND. Se le puede llamar m&#xe1;s de una vez, lo cual har&#xe1; que se concatenen nuevas condiciones separadas tambi&#xe9;n por AND. Usa OR() para dividirlas por OR.</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      
<ul>
        
<li>
          <code>ORDER_BY(String)</code>
        </li>
        
<li>
          <code>ORDER_BY(String...)</code>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade un Nuevo elemento a la clausula ORDER BY concatenado por coma. Se le puede llamar m&#xe1;s de una vez, lo cual har&#xe1; que se concatenen nuevas condiciones separadas tambi&#xe9;n por coma.</td>
  </tr>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>LIMIT(String)</code>
        </li>
        
<li>
          <code>LIMIT(int)</code>
        </li>
      </ul>
    </td>
    
<td>
      Appends a <code>LIMIT</code> clause.
      This method valid when use together with SELECT(), UPDATE() and DELETE().
      And this method is designed to use together with OFFSET() when use SELECT(). (Available since 3.5.2)
    </td>
  </tr>
  
<tr class="a">
    
<td align="left">
      
<ul>
        
<li>
          <code>OFFSET(String)</code>
        </li>
        
<li>
          <code>OFFSET(long)</code>
        </li>
      </ul>
    </td>
    
<td>
      Appends a <code>OFFSET</code> clause.
      This method valid when use together with SELECT().
      And this method is designed to use together with LIMIT(). (Available since 3.5.2)
    </td>
  </tr>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>OFFSET_ROWS(String)</code>
        </li>
        
<li>
          <code>OFFSET_ROWS(long)</code>
        </li>
      </ul>
    </td>
    
<td>
      Appends a <code>OFFSET n ROWS</code> clause.
      This method valid when use together with SELECT().
      And this method is designed to use together with FETCH_FIRST_ROWS_ONLY(). (Available since 3.5.2)
    </td>
  </tr>
  
<tr class="a">
    
<td align="left">
      
<ul>
        
<li>
          <code>FETCH_FIRST_ROWS_ONLY(String)</code>
        </li>
        
<li>
          <code>FETCH_FIRST_ROWS_ONLY(int)</code>
        </li>
      </ul>
    </td>
    
<td>
      Appends a <code>FETCH FIRST n ROWS ONLY</code> clause.
      This method valid when use together with SELECT().
      And this method is designed to use together with OFFSET_ROWS(). (Available since 3.5.2)
    </td>
  </tr>
  
<tr class="b">
    
<td align="left">
      <code>DELETE_FROM(String)</code>
    </td>
    
<td>Comienza una sentencia delete y especifica la tabla donde borrar. Generalmente suele ir seguida de una clausula WHERE!
    </td>
  </tr>
  
<tr class="a">
    
<td align="left">
      <code>INSERT_INTO(String)</code>
    </td>
    
<td>Comienza una sentencia insert y especifica al tabla en la que insertar. Suele ir seguida de una o m&#xe1;s llamadas a VALUES() o INTO_COLUMNS() y INTO_VALUES().
    </td>
  </tr>
  
<tr class="b">
    
<td align="left">
      
<ul>
        
<li>
          <code>SET(String)</code>
        </li>
        
<li>
          <code>SET(String...)</code>
        </li>
      </ul>
    </td>
    
<td>A&#xf1;ade a la lista &#x201c;set&#x201d; de una update.</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      <code>UPDATE(String)</code>
    </td>
    
<td>Comienza una sentencia update y especifica la tabla que modificar Suele ir seguida de una o m&#xe1;s llamadas a SET() y normalmente de una llamada a WHERE().</td>
  </tr>
  
<tr class="b">
    
<td align="left">
      <code>VALUES(String, String)</code>
    </td>
    
<td>A&#xf1;ade a una sentencia insert. El primer par&#xe1;metro es el nombre de columna y el Segundo el valor(es).</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      <code>INTO_COLUMNS(String...)</code>
    </td>
    
<td>
      Appends columns phrase to an insert statement.
      This should be call INTO_VALUES() with together.
    </td>
  </tr>
  
<tr class="b">
    
<td align="left">
      <code>INTO_VALUES(String...)</code>
    </td>
    
<td>
      Appends values phrase to an insert statement.
      This should be call INTO_COLUMNS() with together.
    </td>
  </tr>
  
<tr class="a">
    
<td align="left">
      <code>ADD_ROW()</code>
    </td>
    
<td>
      Add new row for bulk insert. (Available since 3.5.2)
    </td>
  </tr>
          </tbody>
        </table>

        
<p>
          <span class="label important">NOTE</span>
          It is important to note that SQL class writes <code>LIMIT</code>, <code>OFFSET</code>, <code>OFFSET n ROWS</code> and <code>FETCH FIRST n ROWS ONLY</code> clauses into the generated statement as is.
          In other words, the library does not attempt to normalize those values for databases that don&#x2019;t support these clauses directly.
          Therefore, it is very important for users to understand whether or not the target database supports these clauses.
          If the target database does not support these clauses, then it is likely that using this support will create SQL that has runtime errors.
        </p>

        
<p>Since version 3.4.2, you can use variable-length arguments as follows:</p>


<div class="source"><pre class="prettyprint">
public String selectPersonSql() {
  return new SQL()
    .SELECT(&quot;P.ID&quot;, &quot;A.USERNAME&quot;, &quot;A.PASSWORD&quot;, &quot;P.FULL_NAME&quot;, &quot;D.DEPARTMENT_NAME&quot;, &quot;C.COMPANY_NAME&quot;)
    .FROM(&quot;PERSON P&quot;, &quot;ACCOUNT A&quot;)
    .INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;, &quot;COMPANY C on D.COMPANY_ID = C.ID&quot;)
    .WHERE(&quot;P.ID = A.ID&quot;, &quot;P.FULL_NAME like #{name}&quot;)
    .ORDER_BY(&quot;P.ID&quot;, &quot;P.FULL_NAME&quot;)
    .toString();
}

public String insertPersonSql() {
  return new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;)
    .INTO_VALUES(&quot;#{id}&quot;, &quot;#{fullName}&quot;)
    .toString();
}

public String updatePersonSql() {
  return new SQL()
    .UPDATE(&quot;PERSON&quot;)
    .SET(&quot;FULL_NAME = #{fullName}&quot;, &quot;DATE_OF_BIRTH = #{dateOfBirth}&quot;)
    .WHERE(&quot;ID = #{id}&quot;)
    .toString();
}
</pre></div>

        
<p>Since version 3.5.2, you can create insert statement for bulk insert as follow:</p>

        
<div class="source"><pre class="prettyprint">
public String insertPersonsSql() {
  // INSERT INTO PERSON (ID, FULL_NAME)
  //     VALUES (#{mainPerson.id}, #{mainPerson.fullName}) , (#{subPerson.id}, #{subPerson.fullName})
  return new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;)
    .INTO_VALUES(&quot;#{mainPerson.id}&quot;, &quot;#{mainPerson.fullName}&quot;)
    .ADD_ROW()
    .INTO_VALUES(&quot;#{subPerson.id}&quot;, &quot;#{subPerson.fullName}&quot;)
    .toString();
}
</pre></div>

        
<p>Since version 3.5.2, you can create select statement for limiting search result rows clause as follow:</p>

        
<div class="source"><pre class="prettyprint">
public String selectPersonsWithOffsetLimitSql() {
  // SELECT id, name FROM PERSON
  //     LIMIT #{limit} OFFSET #{offset}
  return new SQL()
    .SELECT(&quot;id&quot;, &quot;name&quot;)
    .FROM(&quot;PERSON&quot;)
    .LIMIT(&quot;#{limit}&quot;)
    .OFFSET(&quot;#{offset}&quot;)
    .toString();
}

public String selectPersonsWithFetchFirstSql() {
  // SELECT id, name FROM PERSON
  //     OFFSET #{offset} ROWS FETCH FIRST #{limit} ROWS ONLY
  return new SQL()
    .SELECT(&quot;id&quot;, &quot;name&quot;)
    .FROM(&quot;PERSON&quot;)
    .OFFSET_ROWS(&quot;#{offset}&quot;)
    .FETCH_FIRST_ROWS_ONLY(&quot;#{limit}&quot;)
    .toString();
}
</pre></div>

      </section>

      <section>
<h3><a name="SqlBuilder_y_SelectBuilder_.28DEPRECADAS.29"></a>SqlBuilder y SelectBuilder (DEPRECADAS)</h3>
        
<p>
          En versiones anteriores a la 3.2 optamos por una soluci&#xf3;n distinta, usando una variable ThreadLocal para
          resolver algunas limitaciones de las que hacen los DSLs Java algo incomodos. Sin embargo, esta soluci&#xf3;n est&#xe1; ahora
          desprecada porque los frameworks actuales est&#xe1;n mas orientados a usar patrones builder-type y clases an&#xf3;nimas
          interas para este tipo de cosas. Por lo tanto las clases SelectBuilder y SqlBuilder est&#xe1;n ahora deprecadas.
        </p>
        
<p>
          Los siguientes m&#xe9;todos aplican solo a las clases deprecadas SqlBuilder y SelectBuilder.
        </p>
        
<table border="0" class="table table-striped">
        <thead>
          
<tr class="a">
            
<th>M&#xe9;todo</th>
            
<th>Descripci&#xf3;n</th>
          </tr>
        </thead>
        <tbody>
  
<tr class="b">
    
<td align="left">
      <code>BEGIN()</code> / <code>RESET()</code>
    </td>
    
<td>Estos m&#xe9;todos limpian estado guardad en el ThreadLocal de la clase SelectBuilder, y la preparan para construir una nueva sentencia. BEGIN() se lee mejor cuando se est&#xe1; creando una sentencia. RESET() se lee mejor cuando se est&#xe1; borrando lo hecho anteriormente en medio de una ejecuci&#xf3;n (quiz&#xe1; porque la l&#xf3;gica necesita una sentencia completamente distinta seg&#xfa;n las condiciones).</td>
  </tr>
  
<tr class="a">
    
<td align="left">
      <code>SQL()</code>
    </td>
    
<td>Devuelve la SQL generada y restablece el estado del SelectBuilder (como si se hubiera llamado a un BEGIN() o a un RESET()). Por tanto este m&#xe9;todo solo se puede llamar una vez!</td>
  </tr>
        </tbody>
        </table>

  
<p>La clase SelectBuilder no es m&#xe1;gica, pero es importante que conozcas c&#xf3;mo funcionan.
  SelectBuilder y SqlBuilder usan una combinaci&#xf3;n de imports est&#xe1;ticos y una variable ThreadLocal para permitir una sintaxis m&#xe1;s limpia m&#xe1;s f&#xe1;cilmente usabe con condicionales.
  Para usarlas debes importar est&#xe1;ticamente m&#xe9;todos de las siguientes clases (uno u otro, no ambos):</p>

        
<div class="source"><pre class="prettyprint">import static org.apache.ibatis.jdbc.SelectBuilder.*;</pre></div>
        
<div class="source"><pre class="prettyprint">import static org.apache.ibatis.jdbc.SqlBuilder.*;</pre></div>

        
<p>De esta forma podr&#xe1;s crear m&#xe9;todos como estos:</p>

        
<div class="source"><pre class="prettyprint">
/* DEPRECATED */
public String selectBlogsSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT(&quot;*&quot;);
  FROM(&quot;BLOG&quot;);
  return SQL();
}
        </pre></div>

        
<div class="source"><pre class="prettyprint">
/* DEPRECATED */
private String selectPersonSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
  SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
  FROM(&quot;PERSON P&quot;);
  FROM(&quot;ACCOUNT A&quot;);
  INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
  INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
  WHERE(&quot;P.ID = A.ID&quot;);
  WHERE(&quot;P.FIRST_NAME like ?&quot;);
  OR();
  WHERE(&quot;P.LAST_NAME like ?&quot;);
  GROUP_BY(&quot;P.ID&quot;);
  HAVING(&quot;P.LAST_NAME like ?&quot;);
  OR();
  HAVING(&quot;P.FIRST_NAME like ?&quot;);
  ORDER_BY(&quot;P.ID&quot;);
  ORDER_BY(&quot;P.FULL_NAME&quot;);
  return SQL();
}
        </pre></div>

      </section>
  </section>
  


        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2009&#x2013;2022
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
