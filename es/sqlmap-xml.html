<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/es/xdoc/sqlmap-xml.xml at 24 mayo 2022
 | Rendered using Apache Maven Fluido Skin 1.10.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <meta name="author" content="Clinton Begin" />
    <meta name="author" content="Eduardo Macarron" />
    <title>MyBatis &#x2013; MyBatis 3 | Ficheros XML de mapeo</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.10.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.10.0.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h2>mybatis</h2>
</div>
</div>
          <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="../../images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Publicado el: 24 mayo 2022<span class="divider">|</span>
</li>
          <li id="projectVersion">Versión: 3.5.10</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Manual de Referencia</li>
    <li><a href="index.html" title="Introducción"><span class="none"></span>Introducción</a></li>
    <li><a href="getting-started.html" title="Primeros pasos"><span class="none"></span>Primeros pasos</a></li>
    <li><a href="configuration.html" title="Configuración"><span class="icon-chevron-right"></span>Configuración</a></li>
    <li class="active"><a href="#"><span class="icon-chevron-down"></span>Ficheros XML de mapeo</a>
     <ul class="nav nav-list">
      <li><a href="sqlmap-xml.html#select" title="select"><span class="none"></span>select</a></li>
      <li><a href="sqlmap-xml.html#insert_update_and_delete" title="insert, update and delete"><span class="none"></span>insert, update and delete</a></li>
      <li><a href="sqlmap-xml.html#Parameters" title="Parameters"><span class="none"></span>Parameters</a></li>
      <li><a href="sqlmap-xml.html#Result_Maps" title="Result Maps"><span class="none"></span>Result Maps</a></li>
      <li><a href="sqlmap-xml.html#Auto-mapeo" title="Auto-mapeo"><span class="none"></span>Auto-mapeo</a></li>
      <li><a href="sqlmap-xml.html#cache" title="cache"><span class="none"></span>cache</a></li>
     </ul></li>
    <li><a href="dynamic-sql.html" title="SQL dinámico"><span class="none"></span>SQL dinámico</a></li>
    <li><a href="java-api.html" title="Java API"><span class="icon-chevron-right"></span>Java API</a></li>
    <li><a href="statement-builders.html" title="La clase SQL"><span class="none"></span>La clase SQL</a></li>
    <li><a href="logging.html" title="Logging"><span class="none"></span>Logging</a></li>
   <li class="nav-header">Documentación del proyecto</li>
    <li><a href="project-info.html" title="Información del proyecto"><span class="icon-chevron-right"></span>Información del proyecto</a></li>
    <li><a href="project-reports.html" title="Informes del proyecto"><span class="icon-chevron-right"></span>Informes del proyecto</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Generado por Maven" class="poweredBy"><img class="builtBy" alt="Generado por Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >


  
    <section>
<h2><a name="Ficheros_XML_de_mapeo"></a>Ficheros XML de mapeo</h2>
      
<p>La potencia de MyBatis reside en los Mapped Statements. Aqu&#xed; es donde est&#xe1; la magia. Para lo potentes que son, los ficheros XML de mapeo son relativamente simples. Sin duda, si los comparas con el c&#xf3;digo JDBC equivalente comprobar&#xe1;s que ahorras el 95% del c&#xf3;digo.
      </p>
      
<p>Los ficheros XML de mapeos SQL solo tienen unos pocos elementos de alto nivel (en el orden en el que deber&#xed;an definirse):
      </p>
      
<ul>
        
<li>
          <code>cache</code>
          &#x2013; Configuraci&#xf3;n de la cach&#xe9; para un namespace.
        </li>
        
<li>
          <code>cache-ref</code>
          &#x2013; Referencia a la cach&#xe9; de otro namespace.
        </li>
        
<li>
          <code>resultMap</code>
          &#x2013; El elemento m&#xe1;s complejo y potente que describe como cargar tus objetos a partir de los ResultSets.
        </li>
        
<li>
          <s>
            <code>parameterMap</code>
            &#x2013; Deprecada!  Antigua forma de mapear par&#xe1;metros. Se recomienda el uso de par&#xe1;metros en l&#xed;nea. Este elemento puede ser eliminado en futuras versiones. No se ha documentado en este manual.
          </s>
        </li>
        
<li>
          <code>sql</code>
          &#x2013; Un trozo de SQL reusable que puede utilizarse en otras sentencias.
        </li>
        
<li>
          <code>insert</code>
          &#x2013; Una sentencia INSERT.
        </li>
        
<li>
          <code>update</code>
          &#x2013; A Una sentencia UPDATE.
        </li>
        
<li>
          <code>delete</code>
          &#x2013; Una sentencia DELETE.
        </li>
        
<li>
          <code>select</code>
          &#x2013; Una sentencia SELECT.
        </li>
      </ul>
      
<p>Las siguientes secciones describen estos elementos en detalle, comenzando con los propios elementos.
      </p>

      <section>
<h3><a name="select"></a>select</h3>
        
<p>El select statement es uno de los elementos que m&#xe1;s utilizar&#xe1;s en MyBatis. No es demasiado &#xfa;til almacenar datos en la base de datos si no puedes leerlos, de hecho las aplicaciones suelen leer bastantes m&#xe1;s datos de los que modifican. Por cada insert, update o delete posiblemente haya varias selects. Este es uno de los principios b&#xe1;sicos de MyBatis y la raz&#xf3;n por la que se ha puesto tanto esfuerzo en las consultas y el mapeo de resultados. El select statement es bastante simple para los casos simples. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;
  SELECT * FROM PERSON WHERE ID = #{id}
&lt;/select&gt;</pre></div>

        
<p>Esta sentencia se llama &#x201c;selectPerson&#x201d;, recibe un par&#xe1;metro de tipo in (o Integer), y devuelve una HashMap usando los nombres de columna como clave y los valores del registro como valores.
        </p>

        
<p>
          Observa la notaci&#xf3;n utilizada para los par&#xe1;metros:
        </p>

        
<div class="source"><pre class="prettyprint">#{id}</pre></div>

        
<p>Esto le indica a MyBatis que cree un par&#xe1;metro de PreparedStatement. Con JDBC, ese par&#xe1;metro ir&#xed;a identificado con una &#x201c;?&#x201d; en la select que se le pasa al PreparedStatement, algo as&#xed;:
        </p>

        
<div class="source"><pre class="prettyprint">// C&#xf3;digo JDBC similar, NO MyBatis&#x2026;
String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);</pre></div>

        
<p>JDBC requiere mucho m&#xe1;s c&#xf3;digo para extraer los resultados y mapearlos a una instancia de un objetos, que es precisamente lo que MyBatis evita que tengas que hacer. Aun queda mucho por conocer sobre los par&#xe1;metros y el mapeo de resultados. Todos sus detalles merecen su propio cap&#xed;tulo, y ser&#xe1;n tratados m&#xe1;s adelante.
        </p>

        
<p>El select statement tiene m&#xe1;s atributos que te permiten configurar como debe comportarse cada select statement.</p>

        
<div class="source"><pre class="prettyprint">&lt;select
  id=&quot;selectPerson&quot;
  parameterType=&quot;int&quot;
  parameterMap=&quot;deprecated&quot;
  resultType=&quot;hashmap&quot;
  resultMap=&quot;personResultMap&quot;
  flushCache=&quot;false&quot;
  useCache=&quot;true&quot;
  timeout=&quot;10&quot;
  fetchSize=&quot;256&quot;
  statementType=&quot;PREPARED&quot;
  resultSetType=&quot;FORWARD_ONLY&quot;&gt;</pre></div>

        
<table border="0" class="table table-striped"><caption>Atributos de Select</caption>
          
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>id</code></td>
              
<td>Un identificador &#xfa;nico dentro del namespace que se utiliza para identificar el statement.</td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>parameterType</code></td>
              
<td>El nombre completamente cualificado de la clase o el alias del par&#xe1;metro que se pasar&#xe1; al statement.
              Este atributo es opcional porque MyBatis puede calcular el TypeHandler a utlizar a partir del parametro actual usado en la invocaci&#xf3;n al statement.
              Por defecto: no informado.</td>
            </tr>
            
<tr class="b">
              
<td align="left">
                <s>parameterMap</s>
              </td>
              
<td>
                <s>Este es un atributo obsoleto que permite referenciar a un elemento parameterMap externo. Se recomienda utilizar mapeos en l&#xed;nea (in-line) y el atributo parameterType.
                </s>
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>resultType</code></td>
              
<td>El nombre completamente cualificado o el alias del tipo de retorno de este statement. Ten en cuenta que en el caso de las colecciones el par&#xe1;metro debe ser el tipo contenido en la colecci&#xf3;n, no el propio tipo de la colecci&#xf3;n. Puedes utilizar resultType o resultMap, pero no ambos.
              </td>
          </tr>
            
<tr class="b">
              
<td align="left"><code>resultMap</code></td>
              
<td>Una referencia una un resultMap externo. Los resultMaps son la caracter&#xed;stica m&#xe1;s potente de MyBatis, con un conocimiento detallado de los mismos, se pueden resolver muchos casos complejos de mapeos. Puedes utilizar resultMap O resultType, pero no ambos.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>flushCache</code></td>
              
<td>Informar esta propiedad a true har&#xe1; que la cache local y la de segundo nivel se vac&#xed;en cada vez que se llame a este statement. Por defecto es false para select statements.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>useCache</code></td>
              
<td>Informar esta propiedad a true har&#xe1; que los resultados de la ejecuci&#xf3;n de este statement se cacheen en la cach&#xe9; de segundo nivel. Por defecto es true para las select statements.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>timeout</code></td>
              
<td>Establece el n&#xfa;mero de segundos que el driver esperar&#xe1; a que la base de datos le devuelva una respuesta antes de lanzar una excepci&#xf3;n. Por defecto: no informado (depende del driver de base de datos).
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>fetchSize</code></td>
              
<td>Este es un atributo que &#x201c;sugiere&#x201d; al driver que devuelva los resultados en bloques de filas en el n&#xfa;mero indicado por el par&#xe1;metro. Por defecto: no informado (depende del driver de base de datos).
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>statementType</code></td>
              
<td>Puede valer STATEMENT, PREPARED o CALLABLE. Hace que MyBatis use Statement, PreparedStatement o CallableStatement respectivamente.  Por defecto: PREPARED.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>resultSetType</code></td>
              
<td>Puede valer FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE|DEFAULT(same as unset).  Por defecto: no informado (depende del driver de base de datos).
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>databaseId</code></td>
              
<td>Si hay un DatabaseIdProvider configurado. MyBatis cargar&#xe1; todos los statements sin el atributo <code>databaseId</code>
              o aquellos con un <code>databaseId</code> que coincide con el actual. Si se encuentra un statement con y sin
              <code>databaseId</code> el &#xfa;ltimo se descartar&#xe1;.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>resultOrdered</code></td>
              
<td>De aplicaci&#xf3;n exclusiva para select anidadas. Si es true, se asume que los resultados anidados est&#xe1;n
                agrupados de forma que cuando se lee un nuevo resultado principal nuevo, no habr&#xe1; m&#xe1;s referencias
                a resultados principales anteriores. De esta forma los resultados anidados se rellenar&#xe1;n de
                una manera mucho &#xe1;s eficiente en t&#xe9;rminos de memoria. Defecto:
                <code>false</code>.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <a name="insert_update_and_delete"></a><section id="insert_update_and_delete">
<h3><a name="insert.2C_update_and_delete"></a>insert, update and delete</h3>
        
<p>Los insert, update y delete statements son muy similares en su implementaci&#xf3;n:</p>

        
<div class="source"><pre class="prettyprint">&lt;insert
  id=&quot;insertAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  keyProperty=&quot;&quot;
  keyColumn=&quot;&quot;
  useGeneratedKeys=&quot;&quot;
  timeout=&quot;20&quot;&gt;

&lt;update
  id=&quot;updateAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;

&lt;delete
  id=&quot;deleteAuthor&quot;
  parameterType=&quot;domain.blog.Author&quot;
  flushCache=&quot;true&quot;
  statementType=&quot;PREPARED&quot;
  timeout=&quot;20&quot;&gt;</pre></div>

        
<table border="0" class="table table-striped"><caption>Insert, Update and Delete Attributes</caption>
          
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>id</code></td>
              
<td>Un identificador &#xfa;nico dentro del namespace que se utiliza para identificar el statement.</td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>parameterType</code></td>
              
<td>El nombre completamente cualificado de la clase o el alias del par&#xe1;metro que se pasar&#xe1; al statement.
              Este atributo es opcional porque MyBatis puede calcular el TypeHandler a utlizar a partir del parametro actual usado en la invocaci&#xf3;n al statement.
              Por defecto: no informado.</td>
            </tr>
            
<tr class="b">
              
<td align="left">
                <s><code>parameterMap</code></s>
              </td>
              
<td>
                <s>M&#xe9;todo deprecado de referirse a un parameterMap externo. Usa mapeos inline y el atributo paramterType.</s>
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>flushCache</code></td>
              
<td>Informar esta propiedad a true har&#xe1; que la cach&#xe9; se vac&#xed;e cada vez que se llame a este statement. Por defecto es false para select statements.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>timeout</code></td>
              
<td>Establece el n&#xfa;mero m&#xe1;ximo de segundos que el driver esperar&#xe1; a que la base de datos le devuelva una respuesta antes de lanzar una excepci&#xf3;n. Por defecto: no informado (depende del driver de base de datos).</td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>statementType</code></td>
              
<td>Puede valer STATEMENT, PREPARED o CALLABLE. Hace que MyBatis use Statement, PreparedStatement o CallableStatement respectivamente.  Por defecto: PREPARED.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>useGeneratedKeys</code></td>
              
<td>(solo en insert y update) Indica a MyBatis que utilice el m&#xe9;todo getGeneratedKeys de JDBC para recuperar las claves autogeneras autom&#xe1;ticamente por la base de datos. (ej. campos autoincrementales en SGBD como MySQL o SQL Server).  Por defecto:  false
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>keyProperty</code></td>
              
<td>(solo en insert y update) Indica la propiedad a la que MyBatis debe asignar la clave autogenerada devuelva por getGeneratedKeys o por un elemento hijo de tipo selectKey. Por defecto: no informado. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>keyColumn</code></td>
              
<td>(solo en insert y update) Indica el nombre de la columna en tabla con clave generada. Solo se requiere en algunas bases de datos (como PostgreSQL) donde la
              columna clave no es la primera de la tabla. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>databaseId</code></td>
              
<td>Si hay un DatabaseIdProvider configurado. MyBatis cargar&#xe1; todos los statements sin el atributo <code>databaseId</code>
              o aquellos con un <code>databaseId</code> que coincide con el actual. Si se encuentra un statement con y sin
              <code>databaseId</code> el &#xfa;ltimo se descartar&#xe1;.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>A continuaci&#xf3;n se muestran unos ejemplos de insert, update y delete.</p>

        
<div class="source"><pre class="prettyprint">&lt;insert id=&quot;insertAuthor&quot;&gt;
  insert into Author (id,username,password,email,bio)
  values (#{id},#{username},#{password},#{email},#{bio})
&lt;/insert&gt;

&lt;update id=&quot;updateAuthor&quot;&gt;
  update Author set
    username = #{username},
    password = #{password},
    email = #{email},
    bio = #{bio}
  where id = #{id}
&lt;/update&gt;

&lt;delete id=&quot;deleteAuthor&quot;&gt;
  delete from Author where id = #{id}
&lt;/delete&gt;</pre></div>

        
<p>Tal y como se ha indicado, insert es algo m&#xe1;s complejo dado que dispone de algunos atributos extra para gestionar la generaci&#xf3;n de claves de varias formas distintas.
        </p>

        
<p>
          Primeramente, si tu base de datos soporta la auto-generaci&#xf3;n de claves (ej. MySQL y SQL Server), entonces puedes simplemente informar el atributo useGeneratedKeys=&#x201d;true&#x201d; e informar tambi&#xe9;n en keyProperty el nombre del la propiedad donde guardar el valor y ya has terminado.
Por ejemplo, si la columna id de la tabla Author del ejemplo siguiente fuera autogenerada el insert statement se escribir&#xed;a de la siguiente forma:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;
    keyProperty=&quot;id&quot;&gt;
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
&lt;/insert&gt;</pre></div>

        
<p>
          If your database also supports multi-row insert, you can pass a list or an array of <code>Author</code>s and retrieve the auto-generated keys.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;
    keyProperty=&quot;id&quot;&gt;
  insert into Author (username, password, email, bio) values
  &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;
    (#{item.username}, #{item.password}, #{item.email}, #{item.bio})
  &lt;/foreach&gt;
&lt;/insert&gt;</pre></div>

        
<p>MyBatis puede tratar las claves autogeneradas de otra forma para el caso de las bases de datos que no soportan columnas autogeneradas, o porque su driver JDBC no haya incluido aun dicho soporte.
        </p>

        
<p>A continuaci&#xf3;n se muestra un ejemplo muy simple que genera un id aleatorio (algo que posiblemente nunca har&#xe1;s pero que demuestra la flexibilidad de MyBatis y c&#xf3;mo MyBatis ignora la forma en la que se consigue la clave):
        </p>
        
<div class="source"><pre class="prettyprint">&lt;insert id=&quot;insertAuthor&quot;&gt;
  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1
  &lt;/selectKey&gt;
  insert into Author
    (id, username, password, email,bio, favourite_section)
  values
    (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})
&lt;/insert&gt;</pre></div>
        
<p>
          En el ejemplo anterior, el selectKey statement se ejecuta primero, la propiedad id de Author se informar&#xe1; y posteriormente se invocar&#xe1; al insert statement. Esto proporciona un comportamiento similar a la generaci&#xf3;n de claves en base de datos sin complicar el c&#xf3;digo Java.
        </p>
        
<p>El elemento selectKey tiene el siguiente aspecto:</p>
        
<div class="source"><pre class="prettyprint">&lt;selectKey
  keyProperty=&quot;id&quot;
  resultType=&quot;int&quot;
  order=&quot;BEFORE&quot;
  statementType=&quot;PREPARED&quot;&gt;</pre></div>

        
<table border="0" class="table table-striped"><caption>selectKey Attributes</caption>
          
          <thead>
            
<tr class="a">
              
<th>Attribute</th>
              
<th>Description</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>keyProperty</code></td>
              
<td>La propiedad destino con la que debe informarse el resultado del selectKey statement. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>keyColumn</code></td>
              
<td>Los nombres de columnas en el ResultSet que corresponden con las propiedades. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>resultType</code></td>
              
<td>El tipo de retorno. MyBatis puede adivinarlo pero no est&#xe1; de m&#xe1;s a&#xf1;adirlo para asegurarse. MyBatis permite usar cualquier tipo simple, incluyendo Strings.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>order</code></td>
              
<td>Puede contener BEFORE o AFTER. Si se informa a BEFORE, entonces la obtenci&#xf3;n de la clave se realizar&#xe1; primero, se informar&#xe1; el campo indicado en keyProperty y se ejecutar&#xe1; la insert. Si se informa a AFTER se ejecuta primero la insert y despu&#xe9;s la selectKey &#x2013; Esto es habitual en bases de datos como Oracle que soportan llamadas embebidas a secuencias dentro de una sentencia insert.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>statementType</code></td>
              
<td>Al igual que antes, MyBatis soporta sentencias de tipo STATEMENT, PREPARED and CALLABLE que corresponden Statement, PreparedStatement y CallableStatement respectivamente.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section>
<h3><a name="sql"></a>sql</h3>
        
<p>Este elemento se utiliza para definir un fragmento reusable de c&#xf3;digo SQL que puede ser incluido en otras sentencias. It can be statically (during load phase) parametrized. Different property values can
          vary in include instances. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;</pre></div>

        
<p>Este fragmento de SQL puede ser incluido en otra sentencia, por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
  select
    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt;,
    &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt;&lt;/include&gt;
  from some_table t1
    cross join some_table t2
&lt;/select&gt;</pre></div>

        
<p>
          Property value can be also used in include refid attribute or property values inside include clause, for example:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;sql id=&quot;sometable&quot;&gt;
  ${prefix}Table
&lt;/sql&gt;

&lt;sql id=&quot;someinclude&quot;&gt;
  from
    &lt;include refid=&quot;${include_target}&quot;/&gt;
&lt;/sql&gt;

&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
  select
    field1, field2, field3
  &lt;include refid=&quot;someinclude&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
    &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;
  &lt;/include&gt;
&lt;/select&gt;</pre></div>
      </section>

      <section>
<h3><a name="Parameters"></a>Parameters</h3>
        
<p>En todos los statements anteriores se han mostrado ejemplos de par&#xe1;metros simples. Los par&#xe1;metros son elementos muy potentes en MyBatis. En los casos simples, probablemente el 90% de los casos, no hay mucho que decir sobre ellos, por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
  select id, username, password
  from users
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<p>El ejemplo anterior muestra un mapeo muy simple de par&#xe1;metro con nombre. El atributo parameterType se ha informado a &#x201c;int&#x201d;, por lo tanto el nombre del par&#xe1;metro puede ser cualquiera. Los tipos primitivos y los tipos de datos simples como Integer o String no tienen propiedades relevantes y por tanto el par&#xe1;metro ser&#xe1; reemplazado por su valor. Sin embargo, si pasas un objeto complejo, entonces el comportamiento es distinto. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;
  insert into users (id, username, password)
  values (#{id}, #{username}, #{password})
&lt;/insert&gt;</pre></div>

        
<p>Si se pasa un objeto de tipo User como par&#xe1;metro en este statement, se buscar&#xe1;n en &#xe9;l las propiedades id, username y password  y sus valores se pasar&#xe1;n como par&#xe1;metros de un PreparedStatement.
        </p>

        
<p>Esta es una Buena forma de pasar par&#xe1;metros a statements. Pero los parameter maps (mapas de par&#xe1;metros) tienen otras muchas caracter&#xed;sticas.features of parameter maps.
        </p>

        
<p>Primeramente, es posible especificar un tipo de dato concreto.
        </p>

        
<div class="source"><pre class="prettyprint">#{property,javaType=int,jdbcType=NUMERIC}</pre></div>

        
<p>Como en otros casos, el tipo de Java (javaType) puede casi siempre obtenerse del objeto recibido como par&#xe1;metro, salvo si el objeto es un HashMap. En ese caso debe indicarse el javaType para asegurar que se usa el TypeHandler correcto.
        </p>

        
<p>
          <span class="label important">NOTA</span> El tipo JDBC es obligatorio para todas las columnas que admiten null cuando se pasa un null como valor. Puedes investigar este tema por tu cuenta leyendo los JavaDocs del m&#xe9;todo PreparedStatement.setNull().
        </p>

        
<p>Si quieres customizar aun m&#xe1;s el tratamiento de tipos de datos, puedes indicar un TypeHandler espec&#xed;fico (o un alias), por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}</pre></div>

        
<p>Comienza a parecer demasiado verboso, pero lo cierto es que rara vez necesitaras nada de esto.</p>

        
<p>Para los tipos num&#xe9;ricos hay un atributo numericScale que permite especificar cuantas posiciones decimales son relevantes.
        </p>

        
<div class="source"><pre class="prettyprint">#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}</pre></div>

        
<p>Finalmente, el atributo mode te permite especificar par&#xe1;metros IN, OUT o INOUT. Si un par&#xe1;metro es OUT o INOUT, el valor actual de las propiedades del objeto pasado como par&#xe1;metro ser&#xe1; modificado. Si el mode=OUT (o INOUT) y el jdbcType=CURSOR (ej. Oracle REFCURSOR), debes especificar un resultMap para mapear el RestultSet al tipo del par&#xe1;metro. Ten en cuenta que el atributo javaType es opcional en este caso, dado que se establecer&#xe1; autom&#xe1;ticamente al valor ResultSet en caso de no haberse especificado si el jdbcType es CURSOR.
        </p>

        
<div class="source"><pre class="prettyprint">#{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}</pre></div>

        
<p>MyBatis tambi&#xe9;n soporta tipos de datos avanzados como los structs, pero en este caso debes indicar in el statement el jdbcTypeName en la declaraci&#xf3;n del par&#xe1;metro de tipo OUT.
        </p>

        
<div class="source"><pre class="prettyprint">#{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap}</pre></div>

        
<p>A pesar de estas potentes opciones, la mayor&#xed;a de las veces simplemente debes especificar el nombre de la propiedad y MyBatis adivinar&#xe1; lo dem&#xe1;s. A lo sumo, deber&#xe1;s especificar los jdbcTypes para las columnas que admiten nulos.
        </p>

        
<div class="source"><pre class="prettyprint">#{firstName}
#{middleInitial,jdbcType=VARCHAR}
#{lastName}</pre></div>

        <section>
<h4><a name="Sustituci.C3.B3n_de_Strings"></a>
          Sustituci&#xf3;n de Strings
        </h4>

        
<p>
          Por defecto, usar la sintaxis #{} hace que MyBatis genere propiedades de PreparedStatement y que asigne los valores a par&#xe1;metros de PreparedStatement de forma segura (ej. ?). Aunque esto es m&#xe1;s seguro, m&#xe1;s r&#xe1;pido y casi siempre la opci&#xf3;n adecuada, en algunos casos s&#xf3;lo quieres inyectar un trozo de texto sin modificaciones dentro de la sentencia SQL. Por ejemplo, para el caso de ORDER BY, podr&#xed;as utilizar algo as&#xed;:
        </p>

        
<div class="source"><pre class="prettyprint">ORDER BY ${columnName}</pre></div>

        
<p>
          En este caso MyBatis no alterar&#xe1; el contenido del texto.
        </p>

        
<p>
          String Substitution can be very useful when the metadata(i.e. table name or column name) in the sql statement is dynamic,
          for example, if you want to <code>select</code> from a table by any one of its columns, instead of writing code like:
          </p>
<div class="source"><pre class="prettyprint">
@Select(&quot;select * from user where id = #{id}&quot;)
User findById(@Param(&quot;id&quot;) long id);

@Select(&quot;select * from user where name = #{name}&quot;)
User findByName(@Param(&quot;name&quot;) String name);

@Select(&quot;select * from user where email = #{email}&quot;)
User findByEmail(@Param(&quot;email&quot;) String email);

// and more &quot;findByXxx&quot; method
</pre></div>
          you can just write:
          
<div class="source"><pre class="prettyprint">
@Select(&quot;select * from user where ${column} = #{value}&quot;)
User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value);
</pre></div>
          in which the <code>${column}</code> will be substituted directly and the <code>#{value}</code> will be &quot;prepared&quot;.
          Thus you can just do the same work by:
          
<div class="source"><pre class="prettyprint">
User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);
User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);
User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;);
</pre></div>
        

        
<p>
          This idea can be applied to substitute the table name as well.
        </p>

        
<p>
          <span class="label important">NOTA</span> No es seguro recoger un texto introducido por el usuario e inyectarlo en una sentencia SQL. Esto permite ataques de inyecci&#xf3;n de SQL y por tanto debes impedir que estos campos se informen con la entrada del usuario, o realizar tus propias comprobaciones o escapes.
        </p>
      </section></section>

      <section>
<h3><a name="Result_Maps"></a>Result Maps</h3>
        
<p>
          El elemento resultMap es el elemento m&#xe1;s importante y potente de MyBatis. Te permite eliminar el 90% del c&#xf3;digo que requiere el JDBC para obtener datos de ResultSets, y en algunos casos incluso te permite hacer cosas que no est&#xe1;n siquiera soportadas en JDBC. En realidad, escribir un c&#xf3;digo equivalente para realizar algo similar a un mapeo para un statement complejo podr&#xed;a requerir cientos de l&#xed;neas de c&#xf3;digo. El dise&#xf1;o de los ResultMaps es tal, que los statemets simples no requieren un ResultMap expl&#xed;cito, y los statements m&#xe1;s complejos requieren s&#xf3;lo la informaci&#xf3;n imprescindible para describir relaciones.
        </p>

        
<p>Ya has visto algunos ejemplos de un statement sencillo que no requiere un ResultMap expl&#xed;cito. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt;
  select id, username, hashedPassword
  from some_table
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<p>
          Este statement simplemente obtiene como resultado una HashMap que contiene como claves todas las columnas, tal y como se ha especificado en el atributo resultType. Aunque es muy &#xfa;til en muchos casos, una HashMap no contribuye a un buen modelo de dominio. Es m&#xe1;s probable que tu aplicaci&#xf3;n use JavaBeans o POJOs (Plain Old Java Objects) para el modelo de dominio. MyBatis soporta ambos. Dado el siguiente JavaBean:
        </p>
        
<div class="source"><pre class="prettyprint">package com.someapp.model;
public class User {
  private int id;
  private String username;
  private String hashedPassword;

  public int getId() {
    return id;
  }
  public void setId(int id) {
    this.id = id;
  }
  public String getUsername() {
    return username;
  }
  public void setUsername(String username) {
    this.username = username;
  }
  public String getHashedPassword() {
    return hashedPassword;
  }
  public void setHashedPassword(String hashedPassword) {
    this.hashedPassword = hashedPassword;
  }
}</pre></div>

        
<p>
          Bas&#xe1;ndose en la especificaci&#xf3;n de JavaBeans, la clase anterior tiene 3 propiedades: ip, username y hashedPassword. Todas ellas coinciden exactamente con los nombres de columna en la sentencia select.
        </p>

        
<p>
          Este JavaBean puede mapearse desde un ResultSet de forma casi tan sencilla como la HashMap.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultType=&quot;com.someapp.model.User&quot;&gt;
  select id, username, hashedPassword
  from some_table
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<p>Y recuerda que los TypeAliases son tus amigos. &#xda;salos y de esa forma no tendr&#xe1;s que escribir constantemente el nombre totalmente cualificado (fully qualified). Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;!-- In Config XML file --&gt;
&lt;typeAlias type=&quot;com.someapp.model.User&quot; alias=&quot;User&quot;/&gt;

&lt;!-- In SQL Mapping XML file --&gt;
&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
  select id, username, hashedPassword
  from some_table
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<p>
          En estos casos MyBatis crea autom&#xe1;ticamente un RestulMap entre bastidores para mapear las columnas a las propiedades del JavaBean en base a sus nombres. Si los nombres de las columnas no coinciden exactamente, puedes emplear alias en los nombres de columnas de la sentencia SQL (una caracter&#xed;stica est&#xe1;ndar del SQL) para hacer que coincidan. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultType=&quot;User&quot;&gt;
  select
    user_id             as &quot;id&quot;,
    user_name           as &quot;userName&quot;,
    hashed_password     as &quot;hashedPassword&quot;
  from some_table
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<p>
          Lo mejor de los ResultMaps es que ya has aprendido mucho sobre ellos &#xa1;y ni siquiera los has visto! Los casos sencillos no requieren nada m&#xe1;s que lo que ya has visto. Solo como ejemplo, veamos qu&#xe9; aspecto tendr&#xed;a el &#xfa;ltimo ejemplo utilizando un ResultMap externo, lo cual es otra forma de solucionar las divergencias entre los nombres de columnas y de propiedades.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;user_id&quot; /&gt;
  &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          Y el statement que las referencia utiliza para ello el atributo resultMap (f&#xed;jate que hemos eliminado el atributo resultType). Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<p>
          Ojal&#xe1; todo fuera tan sencillo.
        </p>

        <section>
<h4><a name="Mapeo_de_resultados_avanzado"></a>Mapeo de resultados avanzado</h4>

        
<p>
          MyBatis fue creado con una idea en mente: las bases de datos no siempre son como a ti te gustar&#xed;a que fueran. Nos encantar&#xed;a que todas las bases de datos estuvieran en 3&#xaa; forma normal o BCNF, pero no lo est&#xe1;n. Ser&#xed;a genial que una base de datos encajara perfectamente con todas las aplicaciones que la usan pero no es as&#xed;. Los ResultMaps son la respuesta de MyBatis a este problema.
        </p>

        
<p>Por ejemplo, &#xbf;c&#xf3;mo mapear&#xed;as este statement?</p>

        
<div class="source"><pre class="prettyprint">&lt;!-- Very Complex Statement --&gt;
&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt;
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
&lt;/select&gt;</pre></div>

        
<p>Posiblemente te gustar&#xed;a mapearlo a un modelo de objetos formado por un Blog que ha sido escrito por un Autor, y tiene varios Posts, cada uno de ellos puede tener cero o varios comentarios y tags. A continuaci&#xf3;n puede observarse un ResultMap complejo (asumimos que Author, Blog, Post, Comments y Tags son typeAliases). &#xc9;chale un vistazo, pero no te preocupes, iremos paso a paso. Aunque parece enorme, es en realidad, bastante sencillo.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;!-- Very Complex Result Map --&gt;
&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt;
  &lt;constructor&gt;
    &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt;
  &lt;/constructor&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
    &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt;
  &lt;/association&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt;
    &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt;
      &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt;
      &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt;
    &lt;/collection&gt;
    &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
      &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
    &lt;/discriminator&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>El elemento resultMap tiene varios sub-elementos y una estructura que merece la pena comentar. A continuaci&#xf3;n se muestra una vista conceptual del elemento resultMap.
        </p>

        </section><section>
<h4><a name="resultMap"></a>resultMap</h4>
        
<ul>
          
<li>
            <code>constructor</code> - usado para inyectar resultados en el constructor de la clase durante la instanciaci&#xf3;n
            
<ul>
              
<li><code>idArg</code> - argumento ID; marcar el argumento ID mejora el rendimiento</li>
              
<li><code>arg</code> - un resultado normal inyectado en el constructor</li>
            </ul>
          </li>
          
<li><code>id</code> &#x2013; result ID; marcar los results con ID mejora el rendimiento</li>
          
<li><code>result</code> &#x2013; un resultado normal inyectado en un campo o una propiedad de un JavaBean</li>
          
<li>
            <code>association</code> &#x2013; una asociaci&#xf3;n con un objeto complejo; muchos resultados acabar&#xe1;n siendo de este tipo
            
<ul>
              
<li>result mapping anidado &#x2013; las asociaciones son resultMaps en s&#xed; mismas o pueden apuntar a otro resultMap
              </li>
            </ul>
          </li>
          
<li>
            <code>collection</code> &#x2013; una colecci&#xf3;n de tipos complejos
            
<ul>
              
<li>result mapping anidado &#x2013; las colecciones son resultMaps en s&#xed; mismas o pueden apuntar a otro resultMap</li>
            </ul>
          </li>
          
<li>
            <code>discriminator</code> &#x2013; utiliza un valor del resultado para determinar qu&#xe9; resultMap utilizar
            
<ul>
              
<li>
                <code>case</code> &#x2013; un resultMap basado en un valor concreto
                
<ul>
                  
<li>result mapping anidado &#x2013; un case es un resultMap en s&#xed; mismo y por tanto puede contener a su vez elementos propios de un resultMap o bien apuntar a un resultMap externo.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        
<table border="0" class="table table-striped"><caption>Atributos de ResultMap</caption>
          
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>id</code></td>
              
<td>Un identificador &#xfa;nico dentro del namespace que se utiliza para identificar el result map.</td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>type</code></td>
              
<td>El nombre completamente cualificado de la clase o el alias del par&#xe1;metro que se pasar&#xe1; al statement.</td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>autoMapping</code></td>
              
<td>Si el atributo est&#xe1; presente MyBatis habilita o inhabilita el automapping para este result map.
                El atributo sobreescribe el parametro global autoMappingBehavior. Valor por defecto: no informado.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>
          <span class="label important">Buena pr&#xe1;ctia</span> Construye los ResultMaps de forma incremental. Las pruebas unitarias son de gran ayuda en ellos. Si intentas construir un ResultMap gigantesco como el que se ha visto anteriormente, es muy probable que lo hagas mal y ser&#xe1; dif&#xed;cil trabajar con &#xe9;l. Comienza con una versi&#xf3;n sencilla y evolucionarla paso a paso. Y haz pruebas unitarias! La parte negativa de utilizar frameworks es que a veces son una caja negra (sean opensource o no). Lo mejor que puedes hacer para asegurar que est&#xe1;s consiguiendo el comportamiento que pretendes es escribir pruebas unitarias. Tambi&#xe9;n son de utilidad para enviar bugs.
        </p>

        
<p>
          Las pr&#xf3;ximas secciones har&#xe1;n un recorrido por cada uno de los elementos en detalle.
        </p>

        </section><section>
<h4><a name="id.2C_result"></a>id, result</h4>

        
<div class="source"><pre class="prettyprint">&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;</pre></div>

        
<p>
          Estos son los ResultMaps m&#xe1;s sencillos. Ambos id, y result mapean una columna con una propiedad o campo de un tipo de dato simple (String, int, double, Date, etc.).
        </p>

        
<p>
          La &#xfa;nica diferencia entre ambos es que id marca que dicho resultado es un identificador y dicha propiedad se utilizar&#xe1; en las comparaciones entre instancias de objetos. Esto mejora el rendimiento global y especialmente el rendimiento de la cache y los mapeos anidados (ej. mapeo de joins).
        </p>

        
<p>
          Cada uno tiene los siguientes atributos:
        </p>

        
<table border="0" class="table table-striped"><caption>Atributos de id y result</caption>
          
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>property</code></td>
              
<td>El campo o propiedad al que se va a mapear al valor resultado. Si existe una propiedad tipo JavaBean para el nombre dado, se utilizar&#xe1;. En caso contrario MyBatis buscar&#xe1; un campo con el mismo nombre. En ambos casos puedes utilizar navegaci&#xf3;n compleja usando la notaci&#xf3;n habitual con puntos. Por ejemplo, puedes mapear a algo sencillo como: &#x201c;username&#x201d;, o a algo m&#xe1;s complejo como:  &#x201c;address.street.number&#x201d;.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>column</code></td>
              
<td>El nombre de la columna de la base de datos, o el alias de columna. Es el mismo string que se pasar&#xed;a al m&#xe9;todo resultSet.getString(columnName).
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>javaType</code></td>
              
<td>Un nombre de clase Java totalmente cualificado, o un typeAlias (m&#xe1;s adelante se indican los typeAlias predefinidos). Normalmente MyBatis puede adivinar el tipo de datos de una propiedad de un JavaBean. Sin embargo si usas una HashMap deber&#xe1;s especificar el javaType para obtener el comportamiento deseado.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>jdbcType</code></td>
              
<td>Un tipo JDBC de los tipos soportados que se muestran a continuaci&#xf3;n. El tipo JDBC solo se requiere para columnas que admiten nulos en insert, update o delete. Esto es un requerimiento de JDBC no de MyBatis. Incluso si usas JDBC directamente debes especificar el tipo &#x2013; pero solo para los valores que pueden ser nulos.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>typeHandler</code></td>
              
<td>Ya hemos hablado sobre typeHandlers anteriormente. Usando esta propiedad se puede sobre escribir el typeHandler por defecto. El valor admite un nombre totalmente cualificado o un alias.
              </td>
            </tr>
          </tbody>
        </table>

        </section><section>
<h4><a name="Tipos_JDBC_soportados"></a>Tipos JDBC soportados</h4>

        
<p>Para referencia futura, MyBatis soporta los siguientes tipos JDBC por medio de la enumeraci&#xf3;n JdbcType.</p>

        
<table border="0" class="table table-striped">
          
<tr class="a">
            
<td align="left"><code>BIT</code></td>
            
<td><code>FLOAT</code></td>
            
<td><code>CHAR</code></td>
            
<td><code>TIMESTAMP</code></td>
            
<td><code>OTHER</code></td>
            
<td><code>UNDEFINED</code></td>
          </tr>
          
<tr class="b">
            
<td align="left"><code>TINYINT</code></td>
            
<td><code>REAL</code></td>
            
<td><code>VARCHAR</code></td>
            
<td><code>BINARY</code></td>
            
<td><code>BLOB</code></td>
            
<td><code>NVARCHAR</code></td>
          </tr>
          
<tr class="a">
            
<td align="left"><code>SMALLINT</code></td>
            
<td><code>DOUBLE</code></td>
            
<td><code>LONGVARCHAR</code></td>
            
<td><code>VARBINARY</code></td>
            
<td><code>CLOB</code></td>
            
<td><code>NCHAR</code></td>
          </tr>
          
<tr class="b">
            
<td align="left"><code>INTEGER</code></td>
            
<td><code>NUMERIC</code></td>
            
<td><code>DATE</code></td>
            
<td><code>LONGVARBINARY</code></td>
            
<td><code>BOOLEAN</code></td>
            
<td><code>NCLOB</code></td>
          </tr>
          
<tr class="a">
            
<td align="left"><code>BIGINT</code></td>
            
<td><code>DECIMAL</code></td>
            
<td><code>TIME</code></td>
            
<td><code>NULL</code></td>
            
<td><code>CURSOR</code></td>
            
<td><code>ARRAY</code></td>
          </tr>
        </table>

        </section><section>
<h4><a name="constructor"></a>constructor</h4>

        
<p>Aunque las propiedades funcionan bien en clases tipo Data Transfer Object (DTO), y posiblemente en la mayor parte de tu modelo de dominio, hay algunos casos en los que puedes querer clases inmutables. En ocasiones, las tablas que contienen informaci&#xf3;n que nunca o raramente cambia son apropiadas para las clases inmutables. La inyecci&#xf3;n en el constructor te permite informar valores durante la instanciaci&#xf3;n de la clase, sin necesidad de exponer m&#xe9;todos p&#xfa;blicos. MyBatis tambien soporta propiedades privadas para conseguir esto mismo pero habr&#xe1; quien prefiera utilizar la inyecci&#xf3;n de Constructor. El elemento constructor  permite hacer esto.
        </p>

        
<p>Dado el siguiente constructor:</p>

        
<div class="source"><pre class="prettyprint">public class User {
   //...
   public User(Integer id, String username, int age) {
     //...
  }
//...
}</pre></div>

        
<p>
          In order to inject the results into the constructor, MyBatis needs to identify the constructor for somehow.
          In the following example, MyBatis searches a constructor declared with three parameters: <code>java.lang.Integer</code>, <code>java.lang.String</code> and <code>int</code> in this order.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;constructor&gt;
   &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt;
   &lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&gt;
   &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot;/&gt;
&lt;/constructor&gt;</pre></div>

        
<p>
          When you are dealing with a constructor with many parameters, maintaining the order of arg elements is error-prone.<br />
          Since 3.4.3, by specifying the name of each parameter, you can write arg elements in any order. To reference constructor parameters by their names, you can either add <code>@Param</code> annotation to them or compile the project with '-parameters' compiler option and enable <code>useActualParamName</code> (this option is enabled by default).
          The following example is valid for the same constructor even though the order of the second and the third parameters does not match with the declared order.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;constructor&gt;
   &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot; /&gt;
   &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot; /&gt;
   &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;username&quot; /&gt;
&lt;/constructor&gt;</pre></div>

        
<p>
          <code>javaType</code> can be omitted if there is a property with the same name and type.
        </p>

        
<p>El resto de atributos son los mismos que los de los elementos id y result.</p>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>column</code></td>
              
<td>El nombre de la columna de la base de datos, o el alias de columna. Es el mismo string que se pasar&#xed;a al m&#xe9;todo resultSet.getString(columnName).
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>javaType</code></td>
              
<td>Un nombre de clase Java totalmente cualificado, o un typeAlias (m&#xe1;s adelante se indican los typeAlias predefinidos). Normalmente MyBatis puede adivinar el tipo de datos de una propiedad de un JavaBean. Sin embargo si usas una HashMap deber&#xe1;s especificar el javaType para obtener el comportamiento deseado.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>jdbcType</code></td>
              
<td>Un tipo JDBC de los tipos soportados que se muestran a continuaci&#xf3;n. El tipo JDBC solo se requiere para columnas que admiten nulos en insert, update o delete. Esto es un requerimiento de JDBC no de MyBatis. Incluso si usas JDBC directamente debes especificar el tipo &#x2013; pero solo para los valores que pueden ser nulos.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>typeHandler</code></td>
              
<td>Ya hemos hablado sobre typeHandlers anteriormente. Usando esta propiedad se puede sobre escribir el typeHandler por defecto. El valor admite un nombre totalmente cualificado o un alias.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>select</code></td>
              
<td>El id de otro mapped statement que cargar&#xe1; el tipo complejo asociado a este argumento. Los valores obtenidos de las columnas especificadas en el atributo column se pasar&#xe1;n como par&#xe1;metros al select  statement referenciado. Ver el elemento association  para m&#xe1;s informaci&#xf3;n.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>resultMap</code></td>
              
<td>El id de un resultmap que puede mapear los resultados anidados de este argumento al grafo de objetos (object graph) apropiado. Es una alternativa a llamar a otro select statement. Permite hacer join de varias tablas en un solo ResultSet. Un ResultSet de este tipo puede contener bloques repetidos de datos que deben ser descompuestos y mapeados apropiadamente a un &#xe1;rbol de objetos (object graph). MyBatis te permite encadenar RestultMaps para tratar resultados anidados.  Ver el elemento association  para m&#xe1;s informaci&#xf3;n.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>name</code></td>
              
<td>
                The name of the constructor parameter. Specifying name allows you to write arg elements in any order. See the above explanation. Since 3.4.3.
              </td>
            </tr>
          </tbody>
        </table>

        </section><section>
<h4><a name="association"></a>association</h4>

        
<div class="source"><pre class="prettyprint">&lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
&lt;/association&gt;</pre></div>

        
<p>El elemento association trata las relaciones de tipo &#x201c;tiene-un&#x201d;. Por ejemplo, en nuestro ejemplo, un Blog tiene un Autor. Un mapeo association funciona casi como cualquier otro result. Debes especificar la propiedad destino, el javaType de la propiedad (que normalmente MyBatis puede adivinar), el jdbcType si fuera necesario y un typeHandler si quieres sobre escribir el tratamiento de los valores de retorno.
        </p>

        
<p>Donde la association es distinta es en que debes indicar a MyBatis como cargar la asociaci&#xf3;n. MyBatis puede hacerlo de dos formas distintas:
        </p>

        
<ul>
          
<li>
            Nested Select: Ejecutando otra select que devuelve el tipo complejo deseado.
          </li>
          
<li>
            Nested Results: Usando un ResultMap anidado que trata con los datos repetidos de resultsets provenientes de joins.
          </li>
        </ul>

        
<p>Primeramente, examinemos la propiedades del elemento. Como veras, es distinto de un ResultMap normal solo por los atributos select y resultMap.
        </p>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Attribute</th>
              
<th>Description</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>property</code></td>
              
<td>El campo o propiedad a la que se debe mapear la columna. Si existe una propiedad JavaBean igual al nombre dado, se usar&#xe1;. En caso contrario, MyBatis buscar&#xe1; un campo con el nombre indicado. En ambos casos puedes usar navegaci&#xf3;n compleja usando la notaci&#xf3;n habitual con puntos. Por ejemplo puedes mapear algo simple como: &#x201c;username&#x201d;, o algo m&#xe1;s complejo como:  &#x201c;address.street.number&#x201d;.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>javaType</code></td>
              
<td>Un nombre de clase Java totalmente cualificado, o un typeAlias (m&#xe1;s adelante se indican los typeAlias predefinidos). Normalmente MyBatis puede adivinar el tipo de datos de una propiedad de un JavaBean. Sin embargo si usas una HashMap deber&#xe1;s especificar el javaType para obtener el comportamiento deseado.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>jdbcType</code></td>
              
<td>Un tipo JDBC de los tipos soportados que se muestran a continuaci&#xf3;n. El tipo JDBC solo se requiere para columnas que admiten nulos en insert, update o delete. Esto es un requerimiento de JDBC no de MyBatis. Incluso si usas JDBC directamente debes especificar el tipo &#x2013; pero solo para los valores que pueden ser nulos.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>typeHandler</code></td>
              
<td>Ya hemos hablado sobre typeHandlers anteriormente. Usando esta propiedad se puede sobre escribir el typeHandler por defecto. El valor admite un nombre totalmente cualificado o un alias.
              </td>
            </tr>
          </tbody>
        </table>

        </section><section>
<h4><a name="Select_anidada_en_Association"></a>Select anidada en Association</h4>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>column</code></td>
              
<td>El nombre de la columna de la base de datos, o el alias de columna que contiene el valor que ser&#xe1; pasado como par&#xe1;metro de entrada al statement anidado. Es el mismo string que se pasar&#xed;a al m&#xe9;todo resultSet.getString(columnName). Nota: para tratar con claves compuestas, puedes especificar varios nombres usando esta sintaxis column=&#x201d;{prop1=col1,prop2=col2}&#x201d;. Esto har&#xe1; que se informen las propiedades prop1 y prop2 del objeto par&#xe1;metro del select statement destino
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>select</code></td>
              
<td>El id de otro mapped statement que cargar&#xe1; el tipo complejo asociado a esta propiedad. Los valores obtenidos de las columnas especificadas en el atributo column se pasar&#xe1;n como par&#xe1;metros al select  statement referenciado. A continuaci&#xf3;n se muestra un ejemplo detallado. Nota: para tratar con claves compuestas, puedes especificar varios nombres usando esta sintaxis column=&#x201d;{prop1=col1,prop2=col2}&#x201d;. Esto har&#xe1; que se informen las propiedades prop1 y prop2 del objeto par&#xe1;metro del select statement destino
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>fetchType</code></td>
              
<td>
                Opcional. Los valores v&#xe1;lidos son <code>lazy</code> y <code>eager</code>. Si est&#xe1; presente sobrescribe
                el par&#xe1;metro global de configuraci&#xf3;n <code>lazyLoadingEnabled</code> para este mapping.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>
          Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  SELECT * FROM BLOG WHERE ID = #{id}
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
  SELECT * FROM AUTHOR WHERE ID = #{id}
&lt;/select&gt;</pre></div>

        
<p>Tenemos dos statements: uno para cargar el Blog, el otro para cargar el Autor, y el RestulMap de Blog describe que la sentencia &#x201c;selectAuthor&#x201d; debe utilizarse para cargar su propiedad author.
        </p>

        
<p>Todas las dem&#xe1;s propiedades se cargar&#xe1;n autom&#xe1;ticamente asumiendo que los nombres de propiedad y de columna coinciden.
        </p>

        
<p>Aunque este enfoque es simple, puede no tener un buen rendimiento con gran cantidad de datos. Este problema es conocido como &#x201c;El problema de las N+1 Selects&#x201d;. En resumidas cuentas, el problema de N+1 selects est&#xe1; causado por esto:
        </p>

        
<ul>
          
<li>Ejecutas una sentencia SQL para obtener una lista de registros (el &#x201c;+1&#x201d;).</li>
          
<li>Para cada registro obtenido ejecutas una select para obtener sus detalles (el &#x201c;N&#x201d;).
          </li>
        </ul>

        
<p>Este problema puede provocar la ejecuci&#xf3;n de cientos o miles de sentencias SQL. Lo cual no es demasiado recomendable.
        </p>

        
<p>MyBatis puede cargar esas consultas de forma diferida (lazy load), por lo tanto se evita el coste de lanzar todas esas consultas a la vez. Sin embargo, si cargas la lista e inmediatamente iteras por ella para acceder a los datos anidados, acabar&#xe1;s cargando todos los registros y por lo tanto el rendimiento puede llegar a ser muy malo.
        </p>

        
<p>As&#xed; que, hay otra forma de hacerlo.
        </p>

        </section><section>
<h4><a name="ResultMaps_anidadas_en_Association"></a>ResultMaps anidadas en Association</h4>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Attribute</th>
              
<th>Description</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>resultMap</code></td>
              
<td>El id de un resultmap que puede mapear los resultados anidados de esta asociaci&#xf3;n al grafo de objetos apropiado. Es una alternativa a llamar a otro select statement. Permite hacer join de varias tablas en un solo ResultSet. Un ResultSet de este tipo puede contener bloques repetidos de datos que deben ser descompuestos y mapeados apropiadamente a un &#xe1;rbol de objetos (object graph). MyBatis te permite encadenar RestultMaps para tratar resultados anidados.  A continuaci&#xf3;n se muestra un ejemplo detallado.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>columnPrefix</code></td>
              
<td>
                Cuando se hace una join de varias tablas, es posible que tengas que usar alias de columna para evitar nombres duplicados en el ResultSet.
                El atributo columnPrefix te permite mapear dichas columnas a un Result Map externo. M&#xe1;s adelante se muestra un ejemplo de esta funci&#xf3;n.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>notNullColumn</code></td>
              
<td>
                Por defecto MyBatis s&#xf3;lo crea objetos hijos si al menos una de las columnas mapeadas a las propiedades de dicho objeto es no nula.
                Con este atributo se puede modificar este comportamiento especificando qu&#xe9; columnas deben tener un valor de forma que MyBatis
                s&#xf3;lo crear&#xe1; un objeto hijo si alguna de estas columnas no es nula. Pueden indicarse una lista de columnas usando la coma como separador.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>autoMapping</code></td>
              
<td>If present, MyBatis will enable or disable automapping when mapping the result to this property.
                This attribute overrides the global autoMappingBehavior.
                Note that it has no effect on an external resultMap, so it is pointless to use it with <code>select</code> or <code>resultMap</code> attribute. Default value: unset.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>Previamente has visto un ejemplo muy complejo de asociaciones anidadas. Lo que se muestra a continuaci&#xf3;n es un ejemplo m&#xe1;s simple que muestra c&#xf3;mo funciona esta caracter&#xed;stica. En lugar de ejecutar un statement separado, vamos a hacer una JOIN de las tablas Blog y Author de la siguiente forma:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id            as blog_id,
    B.title         as blog_title,
    B.author_id     as blog_author_id,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
&lt;/select&gt;</pre></div>

        
<p>F&#xed;jate en la join, y el especial cuidado que se ha dedicado a que todos los resultados tengan un alias que les de un nombre &#xfa;nico y claro. Esto hace el mapeo mucho m&#xe1;s sencillo. Ahora podemos mapear los resultados:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot; resultMap=&quot;authorResult&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
  &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
  &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>En el ejemplo anterior puedes ver que la asociaci&#xf3;n &#x201c;author&#x201d; de Blog delega la carga de las instancias de Author en el ResultMap &#x201c;authorResult&#x201d;.
        </p>

        
<p>
          <span class="important">Muy importante</span>: El elemento id tiene un papel muy importante en el mapeo de resultados anidados. Debes especificar siempre una o m&#xe1;s propiedades que se puedan usar para identificar un&#xed;vocamente los resultados. Lo cierto es que MyBatis tambi&#xe9;n va a funcionar si no lo haces pero a costa de una importante penalizaci&#xf3;n en rendimiento. Elige el n&#xfa;mero m&#xed;nimo de propiedades que pueda identificar un&#xed;vocamente un resultado. La clave primaria es una elecci&#xf3;n obvia (incluso si es compuesta).
        </p>

        
<p>En el ejemplo anterior se usa un resultMap externo para mapear la asociaci&#xf3;n. Esto hace que el resultMap del Autor sea reusable. Sin embargo, si no hay necesidad de reusarla o simplemente prefieres colocar todos los mapeos en un solo ResultMap, puedes anidarlo en la propia asociaci&#xf3;n. A continuaci&#xf3;n se muestra un ejemplo de este enfoque:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
  &lt;/association&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          Pero &#xbf;y si el blog tiene un co-autor? La select ser&#xed;a algo as&#xed;:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id            as blog_id,
    B.title         as blog_title,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio,
    CA.id           as co_author_id,
    CA.username     as co_author_username,
    CA.password     as co_author_password,
    CA.email        as co_author_email,
    CA.bio          as co_author_bio
  from Blog B
  left outer join Author A on B.author_id = A.id
  left outer join Author CA on B.co_author_id = CA.id
  where B.id = #{id}
&lt;/select&gt;</pre></div>

        
<p>
          Recuerda que el resultMap de Author est&#xe1; definido de la siguiente forma.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
  &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;
  &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;
  &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          Dado que los nombres de columnas de los resultados difieren de los nombres especidficados en el resultMap, necesitas
          especificar un atributo <code>columnPrefix</code> para poder reusar el result map de Author para los co-autores.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;association property=&quot;author&quot;
    resultMap=&quot;authorResult&quot; /&gt;
  &lt;association property=&quot;coAuthor&quot;
    resultMap=&quot;authorResult&quot;
    columnPrefix=&quot;co_&quot; /&gt;
&lt;/resultMap&gt;</pre></div>

        </section><section>
<h4><a name="ResultSets_m.C3.BAltiples_en_Association"></a>ResultSets m&#xfa;ltiples en Association</h4>

        
<table border="0" class="table table-striped">
          <thead>
            
<tr class="a">
              
<th>Atributo</th>
              
<th>Descripci&#xf3;n</th>
            </tr>
          </thead>
          <tbody>
            
<tr class="b">
              
<td align="left"><code>column</code></td>
              
<td>
                Cuando se usan result sets multiples este atributo especifica las columnas (separadas por comas) que se
                correlar&#xe1;n con las indicadas en <code>foreignColumn</code> para identificar al padre y e hijo de una relaci&#xf3;n.
              </td>
            </tr>
            
<tr class="a">
              
<td align="left"><code>foreignColumn</code></td>
              
<td>
                Identifica los nombres de las columnas que contienen las claves for&#xe1;neas que se emparejar&#xe1;n
                con las columnas especificadas en el atributo <code>column</code> del tipo padre.
              </td>
            </tr>
            
<tr class="b">
              
<td align="left"><code>resultSet</code></td>
              
<td>
                Identifica el nombre del result set de donde se cargar&#xe1;n los datos.
              </td>
            </tr>
          </tbody>
        </table>

        
<p>Desce la versi&#xf3;n 3.2.3 MyBatis proporciona otra forma m&#xe1;s de resolver el problema del N+1.</p>

        
<p>Algunas bases de datos permiten que un procedimiento almacenado devuelva m&#xe1;s de un resultset o
        ejecutar m&#xe1;s de una sentencia a la vez y obtener de vuelta un resultset por cada. Esto se puede usar
        para acceder una sola vez a la base de datos y obtener datos relacionados sin usar una join.</p>

        
<p>En el ejemplo, el procedimiento almacenado deolver&#xe1; dos result sets. El primero contendr&#xe1;
        Blogs y el segundo Authors.</p>

        
<div class="source"><pre class="prettyprint">SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM AUTHOR WHERE ID = #{id}</pre></div>

        
<p>Se debe proporcionar un nombre a cada resultset informando el atributo
        <code>resultSets</code> del mapped statement con una lista de nombres separados por comas.</p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,authors&quot; resultMap=&quot;blogResult&quot; statementType=&quot;CALLABLE&quot;&gt;
  {call getBlogsAndAuthors(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;
</pre></div>

        
<p>
        Ahora podemos especificar que los datos para rellenar la asociaci&#xf3;n &quot;author&quot; vienen en el result set &quot;authors&quot;:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot; resultSet=&quot;authors&quot; column=&quot;author_id&quot; foreignColumn=&quot;id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;bio&quot;/&gt;
  &lt;/association&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>Has visto como se utiliza la asociaci&#xf3;n &#x201c;Tiene Un&#x201d;. Pero &#xbf;qu&#xe9; hay que el &#x201c;Tiene Muchos&#x201d;? Ese es el contenido de la siguiente secci&#xf3;n.
        </p>

        </section><section>
<h4><a name="collection"></a>collection</h4>

        
<div class="source"><pre class="prettyprint">&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
  &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
  &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
&lt;/collection&gt;</pre></div>

        
<p>El elemento collection funciona de forma casi id&#xe9;ntica al association.  En realidad, es tan similar, que documentar todas las similitudes ser&#xed;a redundante. As&#xed; que enfoqu&#xe9;monos en las diferencias.
        </p>

        
<p>Para continuar con nuestro ejemplo anterior, un Blog solo tiene un Autor. Pero un Blog tiene muchos Posts. En la clase Blog esto se representar&#xed;a con algo como:
        </p>

        
<div class="source"><pre class="prettyprint">private List&lt;Post&gt; posts;</pre></div>

        
<p>Para mapear un conjunto de resultados anidados a una Lista como esta, debemos usar el elemento collection. Al igual que el elemento association, podemos usar una select anidada, o bien resultados anidados cargados desde una join.
        </p>

        </section><section>
<h4><a name="Select_anidada_en_Collection"></a>Select anidada en Collection</h4>

        
<p>Primeramente, echemos un vistazo al uso de una select anidada para cargar los Posts de un Blog.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  SELECT * FROM BLOG WHERE ID = #{id}
&lt;/select&gt;

&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt;
  SELECT * FROM POST WHERE BLOG_ID = #{id}
&lt;/select&gt;</pre></div>

        
<p>Hay unas cuantas diferencias que habr&#xe1;s visto de forma inmediata, pero la mayor parte tiene el mismo aspecto que el elemento association  que vimos anteriormente. Primeramente, ver&#xe1;s que estamos usando el elemento collection. Ver&#xe1;s tambi&#xe9;n que hay un nuevo atributo &#x201c;ofType&#x201d;. Este atributo es necesario para distinguir el tipo de la propiedad del JavaBean (o del campo) y el tipo contenido por la colecci&#xf3;n. Por tanto podr&#xed;as leer el siguiente mapeo de esta forma:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;</pre></div>

        
<p>
          <span class="important">Le&#xed;do como</span>: &quot;Una colecci&#xf3;n de posts en un ArrayList de tipos Post.&quot;
        </p>

        
<p>El javaType es casi siempre innecesario, porque MyBatis lo adivinar&#xe1; en la mayor&#xed;a de los casos. As&#xed; que podr&#xed;as acortarlo de esta forma:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;collection property=&quot;posts&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;</pre></div>

        </section><section>
<h4><a name="ResultMaps_anidados_en_Collection"></a>ResultMaps anidados en Collection</h4>

        
<p>A estas alturas, posiblemente ya imaginar&#xe1;s c&#xf3;mo funcionan los ResultMaps anidados en una colecci&#xf3;n porque funcionan exactamente igual que en una asociaci&#xf3;n, salvo por que se a&#xf1;ade igualmente el atributo &#x201c;ofType&#x201d;.
        </p>

        
<p>Primero, echemos un vistazo al SQL:</p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
&lt;/select&gt;</pre></div>

        
<p>Nuevamente hemos hecho una JOIN de las tablas Blog y Post, y hemos tenido cuidado de asegurarnos que las columnas obtenidas tienen un alias adecuado. Ahora, mapear un Blog y colecci&#xf3;n de Post es tan simple como:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>Nuevamente, recuerda la importancia del elemento id,  o lee la secci&#xf3;n de asociaci&#xf3;n si no lo has hecho aun.
        </p>

        
<p>Adem&#xe1;s, si prefieres el formato m&#xe1;s largo que aporta m&#xe1;s reusabilidad a tus ResultMaps, puedes utilizar esta forma alternativa de mapeo:
        </p>
        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultMap=&quot;blogPostResult&quot; columnPrefix=&quot;post_&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;blogPostResult&quot; type=&quot;Post&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
  &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
  &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
&lt;/resultMap&gt;</pre></div>

        </section><section>
<h4><a name="ResultSets_m.C3.BAltiples_en_Collection"></a>ResultSets m&#xfa;ltiples en Collection</h4>

        
<p>
          De la misma forma que hicimos en la association, podemos llamar a un procedimiento almacenado que devuelva
          dos resultsets, uno con Blogs y otro con Posts:
        </p>

        
<div class="source"><pre class="prettyprint">SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}</pre></div>

        
<p>Se debe proporcionar un nombre a cada resultset informando el atributo
        <code>resultSets</code> del mapped statement con una lista de nombres separados por comas.</p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,posts&quot; resultMap=&quot;blogResult&quot;&gt;
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;</pre></div>

        
<p>Especificamos que la collection &quot;posts&quot; se rellenar&#xe1; con datos contenidos en el resultset llamado &quot;posts&quot;:</p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          <span class="label important">NOTA</span> No hay l&#xed;mite en profundidad, amplitud o combinaciones de las asociaciones y colecciones que mapees. Debes tener en cuenta el rendimiento cuando crees los mapeos. Las pruebas unitarias y de rendimiento de tu aplicaci&#xf3;n son de gran utilidad para conocer cuales el mejor enfoque para tu aplicaci&#xf3;n. La parte positiva es que MyBatis te permite cambiar de opini&#xf3;n m&#xe1;s tarde, con muy poco (o ning&#xfa;n) cambio en tu c&#xf3;digo.
        </p>

        
<p>El mapeo de asociaciones y colecciones es un tema denso. La documentaci&#xf3;n solo puede llevarte hasta aqu&#xed;. Con un poco de pr&#xe1;ctica, todo se ir&#xe1; aclarando r&#xe1;pidamente.
        </p>

        </section><section>
<h4><a name="discriminator"></a>discriminator</h4>

        
<div class="source"><pre class="prettyprint">&lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
  &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
&lt;/discriminator&gt;</pre></div>

        
<p>En ocasiones una base de datos puede devolver resultados de muchos y distintos (y esperamos que relacionados) tipos de datos. El elemento discriminator fue dise&#xf1;ado para tratar esta situaci&#xf3;n, y otras como la jerarqu&#xed;as de herencia de clases. El discriminador es bastante f&#xe1;cil de comprender, dado que funciona muy parecido la sentencia switch de Java.
        </p>

        
<p>Una definici&#xf3;n de discriminator especifica los atributos column y javaType. Column indica de d&#xf3;nde debe MyBatis obtener el valor con el que comparar. El javaType es necesario para asegurar que se utiliza el tipo de comparaci&#xf3;n adecuada (aunque la comparaci&#xf3;n de Strings posiblemente funcione casi en todos los casos). Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;
    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;
    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;
    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>En este ejemplo, MyBatis obtendr&#xe1; cada registro del ResultSet y comparar&#xe1; su valor vehicle_type. Si coincide con alguno de los casos del discriminador entonces usar&#xe1; el ResultMap especificado en cada caso. Esto se hace de forma exclusiva, es decir, el resto del ResultMap se ignora (a no ser que se extienda, de lo que hablaremos en un Segundo). Si no coincide ninguno de los casos MyBatis utilizar&#xe1; el resultmap definido fuera del bloque discriminator.  Por tanto si carResult ha sido declarado de la siguiente forma:
        </p>


        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;carResult&quot; type=&quot;Car&quot;&gt;
  &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>Entonces solo la propiedad doorCount se cargar&#xe1;. Esto se hace as&#xed; para permitir grupos de discriminadores completamente independientes, incluso que no tengan ninguna relaci&#xf3;n con el ResultMap padre. En este caso sabemos que hay relaci&#xf3;n entre coches y veh&#xed;culos, dado que un coche es-un veh&#xed;culo. Por tanto queremos que el resto de propiedades se carguen tambi&#xe9;n, as&#xed; que con un simple cambio en el ResultMap habremos terminado.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;carResult&quot; type=&quot;Car&quot; extends=&quot;vehicleResult&quot;&gt;
  &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>Ahora, se cargar&#xe1;n todas las propiedades tanto de vehicleResult como de carResult.
        </p>

        
<p>Nuevamente, hay quien puede pensar que la definici&#xf3;n externa es tediosa. Por tanto hay una sintaxis alternativa para los que prefieran un estilo m&#xe1;s conciso. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultType=&quot;carResult&quot;&gt;
      &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt;
    &lt;/case&gt;
    &lt;case value=&quot;2&quot; resultType=&quot;truckResult&quot;&gt;
      &lt;result property=&quot;boxSize&quot; column=&quot;box_size&quot; /&gt;
      &lt;result property=&quot;extendedCab&quot; column=&quot;extended_cab&quot; /&gt;
    &lt;/case&gt;
    &lt;case value=&quot;3&quot; resultType=&quot;vanResult&quot;&gt;
      &lt;result property=&quot;powerSlidingDoor&quot; column=&quot;power_sliding_door&quot; /&gt;
    &lt;/case&gt;
    &lt;case value=&quot;4&quot; resultType=&quot;suvResult&quot;&gt;
      &lt;result property=&quot;allWheelDrive&quot; column=&quot;all_wheel_drive&quot; /&gt;
    &lt;/case&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          <span class="label important">NOTA</span> Recuerda que todos estos son ResultMaps, y que si no indicas ning&#xfa;n result en ellos, MyBatis mapear&#xe1; autom&#xe1;ticamente las columnas a las propiedades por ti. As&#xed; que en muchos casos estos ejemplos son m&#xe1;s verbosos de lo que realmente debieran ser. Dicho esto, la mayor&#xed;a de las bases de datos son bastante complejas y muchas veces no podemos depender de ello para todos los casos.
        </p>

      </section></section>
      <section>
<h3><a name="Auto-mapeo"></a>Auto-mapeo</h3>

        
<p>
          Como ya has visto en las secciones previas, en los casos simples MyBatis puede auto-mapear los resultados por ti y en el resto de los casos
          es posible que tengas que crear un result map. Pero, como ver&#xe1;s en esta secci&#xf3;n tambi&#xe9;n puedes combinar ambas estrategias.
          Veamos en detalle c&#xf3;mo funciona el auto-mapeo.
        </p>

        
<p>
          Al auto-mapear resultados MyBatis obtiene el nombre de columna y busca una propiedad con el mismo nombre sin tener en cuenta las may&#xfa;sculas.
          Es decir, si se encuentra una columna <i>ID</i> y una propiedad <i>id</i>, MyBatis informar&#xe1; la propiedad <i>id</i> con el valor de la columna
          <i>ID</i>.
        </p>

        
<p>
          Normalmente las columnas de base de datos se nombran usando may&#xfa;sculas y separando las palabras con un subrayado, mientras que las propiedades
          java se nombran habitualmente siguiendo la notaci&#xf3;n tipo camelcase. Para habilitar el auto-mapeo entre ellas informa el par&#xe1;metro de configuraci&#xf3;n
          <code>mapUnderscoreToCamelCase</code> a true.
        </p>

        
<p>
          El auto-mapeo funciona incluso cuando hay un result map espec&#xed;fico. Cuando esto sucede, para cada result map, todas las columnas que est&#xe1;n
          presentes en el ResultSet y que no tienen un mapeo manual se auto-mapear&#xe1;n. Posteriormente se procesar&#xe1;n los mapeos manuales.
          En el siguiente ejemplo las columnas <i>id</i> y <i>userName</i> se auto-mapear&#xe1;n y la columna <i>hashed_password</i> se mapear&#xe1; manualmente.</p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&gt;
  select
    user_id             as &quot;id&quot;,
    user_name           as &quot;userName&quot;,
    hashed_password
  from some_table
  where id = #{id}
&lt;/select&gt;</pre></div>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot;&gt;
  &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          Hay tres niveles de auto-mapeo:
        </p>

        
<ul>
          
<li>
            <code>NONE</code> - desactiva el auto-mapeo. Solo las propiedades mapeadas manaulmente se informar&#xe1;n.
          </li>
          
<li>
            <code>PARTIAL</code> - auto-mapea todos los resultados que no tienen un mapeo anidado definido en su interior (joins).
          </li>
          
<li>
            <code>FULL</code> - lo auto-mapea todo.
          </li>
        </ul>

        
<p>
          El valor por defecto es <code>PARTIAL</code>, y hay una raz&#xf3;n para ello. Cuandos se utiliza <code>FULL</code> el auto-mapeo se
          realiza cuando se est&#xe1;n procesando resultados de joins y las joins obtienen datos de distintas entidades en la misma fila
          por lo tanto podr&#xed;an producirse mapeos autom&#xe1;ticos indeseados. Para comprender el riesgo observa el siguiente ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  select
    B.id,
    B.title,
    A.username,
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
&lt;/select&gt;</pre></div>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;association property=&quot;author&quot; resultMap=&quot;authorResult&quot;/&gt;
&lt;/resultMap&gt;

&lt;resultMap id=&quot;authorResult&quot; type=&quot;Author&quot;&gt;
  &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;
&lt;/resultMap&gt;</pre></div>

        
<p>
          Con este result map ambos <i>Blog</i> y <i>Author</i> se auto-mapear&#xe1;n. Pero f&#xed;jate que <i>Author</i> tiene un <i>id</i> y que hay una
          columna con nombre <i>id</i> en el ResultSet por lo que el id de Author se rellenar&#xe1; con el id de Blog, y eso no era lo que esperabas.
          Por tanto usa la opci&#xf3;n <code>FULL</code> con cuidado.
        </p>

        
<p>
          Independientemente del nivel de auto-mapeo configurado puedes activar o desactivar el auto-mapeo para un ResultMap especifico
          a&#xf1;adiendole el atributo<code>autoMapping</code>:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;resultMap id=&quot;userResultMap&quot; type=&quot;User&quot; autoMapping=&quot;false&quot;&gt;
  &lt;result property=&quot;password&quot; column=&quot;hashed_password&quot;/&gt;
&lt;/resultMap&gt;</pre></div>


      </section>
      <section>
<h3><a name="cache"></a>cache</h3>
        
<p>MyBatis incluye una funcionalidad de cach&#xe9; transaccional de segundo nivel muy potente que es ampliamente configurable y personalizable. Se han realizado muchos cambios en la cach&#xe9; de MyBatis 3 para hacer la a la vez m&#xe1;s potente y m&#xe1;s sencilla de configurar.
        </p>

        
<p>
           Por defecto la &#xfa;nica cach&#xe9; activa es la cach&#xe9; local de sesi&#xf3;n que se utiliza &#xfa;nicamente durante la duraci&#xf3;n de una sesi&#xf3;n.
           Para habilitar la cach&#xe9; de segundo nivel global simplemente necesitas a&#xf1;adir una l&#xed;nea en tu fichero de mapping:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;cache/&gt;</pre></div>

        
<p>Eso es todo literalmente. El efecto de esta sencilla l&#xed;nea es el siguiente:
        </p>

        
<ul>
          
<li>Todos los resultados de las sentencias select en el mapped statement se cachear&#xe1;n.</li>
          
<li>Todas las sentencias insert, update y delete del mapped statement vaciar&#xe1;n la cach&#xe9;.</li>
          
<li>La cach&#xe9; usar&#xe1;n un algoritmo de reemplazo tipo Least Recently Used (LRU).</li>
          
<li>La cach&#xe9; no se vaciar&#xe1; por tiempo (ej. no Flush Interval).</li>
          
<li>La cach&#xe9; guardar&#xe1; 1024 referencias a listas u objetos (seg&#xfa;n lo que devuelva el statement).</li>
          
<li>La cach&#xe9; puede tratarse como una cache de tipo lectura/escritura, lo cual significa que los objetos obtenidos no se comparten y pueden modificarse con seguridad por el llamante sin interferir en otras potenciales modificaciones realizadas por otros llamantes o hilos.</li>
        </ul>

        
<p>
          <span class="label important">NOTE</span> The cache will only apply to statements declared in the mapping file
          where the cache tag is located. If you are using the Java API in conjunction with the XML mapping files, then
          statements declared in the companion interface will not be cached by default. You will need to refer to the
          cache region using the @CacheNamespaceRef annotation.
        </p>

        
<p>Todas estas propiedades son modificables mediante atributos del elemento cache. Por ejemplo:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;cache
  eviction=&quot;FIFO&quot;
  flushInterval=&quot;60000&quot;
  size=&quot;512&quot;
  readOnly=&quot;true&quot;/&gt;</pre></div>

        
<p>Esta configuraci&#xf3;n m&#xe1;s avanzada de cach&#xe9; crea una cache de tipo FIFO que se vac&#xed;a cada 60 segundos, guarda hasta 512 referencias a objetos o listas, y los objetos devueltos son considerados de solo lectura, esto es, que modificarlos puede crear problemas en llamantes de otros hilos.
        </p>

        
<p>Las pol&#xed;ticas de reemplazo son las siguientes:
        </p>

        
<ul>
          
<li>
            <code>LRU</code> &#x2013; Least Recently Used: Borra los objetos que llevan m&#xe1;s tiempo sin ser usados.
          </li>
          
<li><code>FIFO</code> &#x2013; First In First Out: Borra los objetos en el mismo orden en el que entraron en la cach&#xe9;.</li>
          
<li>
            <code>SOFT</code> &#x2013; Soft Reference: Borra los objetos en base a las referencias Soft del Garbage Collector.
          </li>
          
<li>
            <code>WEAK</code> &#x2013; Weak Reference: Es m&#xe1;s agresivo y borra objetos bas&#xe1;ndose en el estado del Garbage Collector y las referencias d&#xe9;biles.
          </li>
        </ul>

        
<p>LRU es la pol&#xed;tica por defecto.</p>

        
<p>El atributo flushInterval acepta un entero positivo y deber&#xed;a representar un lapso de tiempo razonable en milisegundos. No est&#xe1; activo por defecto, por tanto no hay intervalo de vaciado y la cach&#xe9; solo se vac&#xed;a mediante llamadas a otros statements.
        </p>

        
<p>El atributo size acepta un entero positivo, ten en cuenta el tama&#xf1;o de los objetos que quieres cachear y la cantidad de memoria de la que dispone. Por defecto es 1024.
        </p>

        
<p>El atributo readOnly puede informarse con true o false. Una cach&#xe9; de solo lectura devuelve la misma instancia de objeto a todos los llamantes. Por lo tanto estos objetos no deben modificarse. Por otro lado esto proporciona una mejora en el rendimiento. Una cach&#xe9; de tipo lectura-escritura devuelve una copia (v&#xed;a serializaci&#xf3;n) del objeto cacheado. Esto es m&#xe1;s lento, pero m&#xe1;s seguro, y por ello el valor por defecto es false.
        </p>

        
<p>
          <span class="label important">NOTA</span> La cach&#xe9; de segundo nivel es transaccional. Esto significa que solo es actualizada cuando
          una sessi&#xf3;n acaba con commit o cuando acaba con rollback pero no se ha ejecutado ninguna sentencia insert/delete/update
          con el par&#xe1;metro flushCache=true.
        </p>

        <section>
<h4><a name="Como_usar_una_cach.C3.A9_personalizada"></a>Como usar una cach&#xe9; personalizada</h4>

        
<p>Adem&#xe1;s de poder personalizar la cach&#xe9; de las formas indicadas, puedes sustituir el sistema de cach&#xe9; por completo y proporcionar tu propia cach&#xe9;, o crear un adaptador para cach&#xe9;s de terceros.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;</pre></div>

        
<p>Este ejemplo muestra c&#xf3;mo usar una cach&#xe9; personalizada. La clase especificada en el atributo type debe implementar el interfaz org.apache.ibatis.cache.Cache y proporcionar un constructor que recibe como par&#xe1;metro un String id. Este es uno de los interfaces m&#xe1;s complejos de MyBatis pero su funcionalidad es simple.
        </p>

        
<div class="source"><pre class="prettyprint">public interface Cache {
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
}</pre></div>

        
<p>Para configurar tu cach&#xe9; a&#xf1;ade simplemente propiedades tipo JavaBean a tu implementaci&#xf3;n, y pasa las propiedades usando el elemento cache, por ejemplo el siguiente ejemplo llamar&#xe1; a un m&#xe9;todo &#x201c;setCacheFile(String file)&#x201d; en tu implementaci&#xf3;n de cach&#xe9;:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;&gt;
  &lt;property name=&quot;cacheFile&quot; value=&quot;/tmp/my-custom-cache.tmp&quot;/&gt;
&lt;/cache&gt;</pre></div>

        
<p>
          Puedes utilizar propiedades JavaBean de cualquier tipo simple y MyBatis har&#xe1; la conversi&#xf3;n.
          And you can specify a placeholder(e.g. <code>${cache.file}</code>) to replace value defined at <a href="configuration.html#properties">configuration properties</a>.
        </p>

        
<p>
          Since 3.4.2, the MyBatis has been supported to call an initialization method after it's set all properties.
          If you want to use this feature, please implements the <code>org.apache.ibatis.builder.InitializingObject</code>
          interface on your custom cache class.
        </p>

        
<div class="source"><pre class="prettyprint">public interface InitializingObject {
  void initialize() throws Exception;
}</pre></div>

        
<p><span class="label important">NOTE</span>
          Los parametros de configuraci&#xf3;n de la cache (eviction, read write..etc.) explicados anteriormente no aplican cuando se usa
          una cach&#xe9; personalizada.
        </p>

        
<p>Es importante recordar que la configuraci&#xf3;n de la caches y la instancia de cach&#xe9; est&#xe1; asociadas al namespace del fichero SQL Map. Y por tanto, a todas las sentencias del mismo namespace dado que la cache est&#xe1; asociada a &#xe9;l. Los statements pueden modificar c&#xf3;mo interact&#xfa;an con la cach&#xe9;, o excluirse a s&#xed; mismos completamente utilizando dos atributos simples. Por defecto los statements est&#xe1;n configurados as&#xed;:
        </p>

        
<div class="source"><pre class="prettyprint">&lt;select ... flushCache=&quot;false&quot; useCache=&quot;true&quot;/&gt;
&lt;insert ... flushCache=&quot;true&quot;/&gt;
&lt;update ... flushCache=&quot;true&quot;/&gt;
&lt;delete ... flushCache=&quot;true&quot;/&gt;</pre></div>

        
<p>Dado que estos son los valores por defecto, no deber&#xed;as nunca configurar un statement de esa forma. En cambio, utiliza los atributos flushCache y useCache si quieres modificar el valor por defecto. Por ejemplo en algunos casos quieres excluir los resultados de un cach&#xe9; particular de la cach&#xe9;, o quiz&#xe1; quieras que un statement de tipo select vac&#xed;e la cach&#xe9;. O de forma similar, puede que quieras que algunas update statements no la vac&#xed;en.
        </p>

          </section><section>
<h4><a name="cache-ref"></a>cache-ref</h4>
        
<p>Recuerda que en la secci&#xf3;n anterior se indic&#xf3; que la cach&#xe9; de un namespace ser&#xed;a utilizada por statements del mismo namespace. Es posible que en alguna ocasi&#xf3;n quieras compartir la misma configuraci&#xf3;n de cach&#xe9; e instancia entre statements de distintos namespaces. En estos casos puedes hacer referencia a otra cach&#xe9; usando el elemento cache-ref.
        </p>

        
<div class="source"><pre class="prettyprint">&lt;cache-ref namespace=&quot;com.someone.application.data.SomeMapper&quot;/&gt;</pre></div>
      </section></section>
    </section>
  

        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2009&#x2013;2022
<a href="https://www.mybatis.org/">MyBatis.org</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
